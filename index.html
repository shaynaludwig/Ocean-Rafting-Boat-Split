<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ocean Rafting â€” Boat Split</title>
<style>
  :root{
    --bg:#0b1222; --panel:#0f172a; --card:#0e1626; --line:#1e293b; --text:#e5e7eb; --muted:#9ca3af;
    --chip:#12243c; --accent:#1e3a8a; --ok:#16a34a; --warn:#f59e0b; --bad:#ef4444;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--text);font:14px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:20px 24px;border-bottom:1px solid var(--line);background:linear-gradient(180deg,#0b1222 0%,#0a0f1c 100%)}
  header h1{margin:0;font-size:22px;font-weight:700}
  header p{margin:4px 0 0;color:var(--muted)}
  .layout{display:grid;grid-template-columns:420px 1fr;gap:18px;max-width:1600px;margin:0 auto;padding:18px}
  @media (max-width: 980px){.layout{grid-template-columns:1fr}}
  .left{position:sticky;top:10px;height:fit-content}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:14px;padding:14px}
  .panel+.panel{margin-top:12px}
  .section-title{font-weight:700;letter-spacing:.3px;text-transform:uppercase;color:#cbd5e1;font-size:12px;margin:0 0 10px}
  label{display:block;margin:10px 0 6px;color:#cbd5e1}
  input[type="file"],select,input[type="number"],input[type="text"]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #223047;background:#0a1220;color:#e5e7eb}
  .muted{color:var(--muted)}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;border:1px solid #244161;background:#0b1e33;color:#fff;cursor:pointer}
  .btn:hover{border-color:#2f5c8a}
  .btn-primary{background:#0f2a4a;border-color:#1c3e64}
  .btn-danger{background:#2a1010;border-color:#5a1d1d}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>*{flex:1 1 120px}
  .boats{display:grid;gap:10px;grid-template-columns:1fr}
  @media(min-width:560px){.boats{grid-template-columns:1fr 1fr}}
  .boat{background:var(--card);border:1px solid var(--line);border-radius:12px;padding:12px}
  .boat h4{margin:0 0 6px;font-size:14px}
  .just{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .chips{display:flex;flex-wrap:wrap;gap:8px}
  .chip{background:#0c2036;border:1px solid #1f3a59;color:#cbd5e1;padding:5px 9px;border-radius:999px;font-size:12px}
  .status{margin:8px 0 0;color:#cbd5e1}
  .right .panel{min-height:520px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid var(--line);vertical-align:top}
  th{position:sticky;top:0;background:var(--card);text-align:left;font-weight:700}
  .pill{display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid var(--line);font-size:11px}
  .ok{background:rgba(22,163,74,.15);border-color:rgba(22,163,74,.4)}
  .warn{background:rgba(245,158,11,.12);border-color:rgba(245,158,11,.4)}
  .bad{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.4)}
  .tag{background:rgba(34,211,238,.12);border-color:rgba(34,211,238,.4);color:#a5f3fc}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace}
</style>
</head>
<body>
<header>
  <h1>Boat Split</h1>
  <p>Upload CSV â†’ set tour â†’ tag boats (DDI/Fly/EE/WH) â†’ remove boats (Ã—) â†’ Allocate â†’ Download CSV</p>
</header>

<main class="layout">
  <aside class="left">
    <div class="panel">
      <div class="section-title">1) Upload</div>
      <input type="file" id="file" accept=".csv" />
      <div class="muted" style="margin-top:6px">Columns expected: <span class="mono chip">Client</span> <span class="mono chip">No. Pass.</span> <span class="mono chip">P/U Point</span> <span class="mono chip">Time</span> <span class="mono chip">Pickup Notes</span></div>
    </div>

    <div class="panel">
      <div class="section-title">2) Tour</div>
      <label>North / South</label>
      <select id="tour"><option value="north">Northern</option><option value="south">Southern</option></select>
    </div>

    <div class="panel">
      <div class="section-title">3) Boats & Tags</div>
      <div class="muted" style="margin-bottom:8px">Reorder (â–²/â–¼), set tags (DDI / Fly-Raft / EE / WH), hold seats, or remove with Ã—. DDI & Fly are mutually exclusive.</div>
      <div id="boats" class="boats"></div>
      <div class="toolbar" style="margin-top:10px">
        <button id="resetBoats" class="btn">Reset boats</button>
        <button id="run" class="btn btn-primary">Allocate</button>
        <button id="download" class="btn" disabled>Download CSV</button>
      </div>
      <div id="messages" class="chips" style="margin-top:10px"></div>
    </div>
    <div class="panel">
      <div class="section-title">Status</div>
      <div id="status" class="status">No file loaded. (v=fr-guard2)</div>
    </div>
  </aside>

  <section class="right">
    <div class="panel">
      <div class="section-title">Results</div>
      <div id="results"></div>
    </div>
  </section>
</main>

<script>
// Hard surfacing of runtime errors on the page
window.onerror = (msg, src, line, col, err) => {
  const pre = document.createElement('pre');
  pre.style.cssText='white-space:pre-wrap;background:#3b0f0f;color:#ffecec;padding:10px;border:1px solid #7f1d1d;border-radius:8px;margin:10px 0';
  pre.textContent = `Script error:\n${msg}\n${src?`at ${src}:${line}:${col}\n`:''}${err&&err.stack?err.stack:''}`;
  document.querySelector('.right .panel').prepend(pre);
};

/* ---------- Defaults ---------- */
const DEFAULT_BOATS = [
  { name: "Joyride",        seats: 32, toilet: true },
  { name: "Thunderstruck",  seats: 32, toilet: true },
  { name: "Black Betty",    seats: 32, toilet: true },
  { name: "Wipeout",        seats: 32, toilet: true },
  { name: "Riptide",        seats: 32, toilet: true },
  { name: "Thrilla",        seats: 25, toilet: false },
  { name: "Jammin",         seats: 22, toilet: true },
  { name: "Wildthing",      seats: 19, toilet: false },
];

let rows=[], boats=[];

/* ---------- Helpers ---------- */
const el = id => document.getElementById(id);
const setStatus = s => el('status').textContent = s;
const messagesEl = el('messages');
function clearMsgs(){ messagesEl.innerHTML=''; }
function pushMsg(text,tone=''){ const m=document.createElement('span'); m.className='chip'; const col = tone==='ok'?'rgba(22,163,74,.5)':tone==='warn'?'rgba(245,158,11,.5)':tone==='bad'?'rgba(239,68,68,.5)':'#1f3a59'; m.style.borderColor=col; m.textContent=text; messagesEl.appendChild(m); }
function norm(s){ return (s??'').toString().trim(); }
function ownName(client){ return norm(client.split(/\*(?:TW|MAP)\*/i)[0]); }
function normalizeFull(name){ return ownName(name).replace(/\(\s*F\s*\+\s*R\s*\)/ig,'').replace(/\s+/g,' ').toLowerCase(); }
function edgeOrder(n){ const res=[]; for(let a=0,b=n-1;a<=b;a++,b--){ res.push(a); if(b>a) res.push(b);} return res; }
const escapeHtml = s => (s??'').replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m]));
const toCSV = rows => rows.map(r=>r.map(v=>{ if(v==null)return''; v=String(v); return /[",\n]/.test(v)?'"'+v.replace(/"/g,'""')+'"':v; }).join(',')).join('\n');

/* CSV parse (robust quotes) */
function parseCSV(text){
  const rows=[]; let cur='',row=[],inQ=false,i=0;
  while(i<text.length){ const ch=text[i];
    if(inQ){ if(ch==='"'){ if(text[i+1]==='"'){cur+='"';i+=2;continue} inQ=false;i++;continue } cur+=ch; i++; continue; }
    if(ch==='"'){ inQ=true; i++; continue; }
    if(ch===','){ row.push(cur); cur=''; i++; continue; }
    if(ch==='\r'){ i++; continue; }
    if(ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=''; i++; continue; }
    cur+=ch; i++;
  }
  row.push(cur); rows.push(row);
  if(rows.length && rows[rows.length-1].every(c=>c==='')) rows.pop();
  return rows;
}
const COL_ALIASES = {
  client:["client","name","full name","passenger","pax name"],
  num:["no. pass.","no pass","passengers","pax","qty","count"],
  pu:["p/u point","pickup point","p/u","pick up","pickup","location"],
  time:["time","pickup time","p/u time"],
  notes:["pickup notes","notes","comments","pu comments","p/u notes"],
  phone:["phone","mobile"]
};
function findColIndex(h,keys){
  const lower=h.map(x=>x.toLowerCase());
  for(const k of keys){ const i=lower.indexOf(k); if(i!==-1) return i; }
  for(let i=0;i<lower.length;i++){ if(keys.some(k=>lower[i].includes(k))) return i; }
  return -1;
}
function parseTimeToSortable(t){
  if(!t) return null; let s=t.toString().trim(); if(!s) return null;
  s=s.replace('.',':'); const ampm=/am|pm/i.test(s)?s.match(/am|pm/i)[0].toLowerCase():null;
  s=s.replace(/[^0-9:]/g,''); if(/^\d{3,4}$/.test(s)){ s=(s.length===3?'0'+s:s); s=s.slice(0,2)+':'+s.slice(2); }
  if(!/^\d{1,2}:\d{2}$/.test(s)) return null;
  let [hh,mm]=s.split(':').map(n=>parseInt(n,10)); if(ampm){ if(ampm==='pm'&&hh<12)hh+=12; if(ampm==='am'&&hh===12)hh=0; }
  if(hh>=0&&hh<24&&mm>=0&&mm<60) return hh*60+mm; return null;
}
function quartileSection(mins, sortedDistinct){
  if(mins==null) return 'Unknown'; const n=sortedDistinct.length; if(!n) return 'Unknown';
  const q1=sortedDistinct[Math.floor(n*.25)], q2=sortedDistinct[Math.floor(n*.50)], q3=sortedDistinct[Math.floor(n*.75)];
  if(mins<=q1) return '1st'; if(mins<=q2) return '2nd'; if(mins<=q3) return '3rd'; return '4th';
}

/* Boats UI */
function cloneBoats(){ return DEFAULT_BOATS.map(b=>({...b, tagDDI:false, tagFly:false, tagEE:false, tagWH:false, hold:0 })); }
function renderBoats(){
  const wrap = el('boats'); wrap.innerHTML='';
  if(!boats.length){ const d=document.createElement('div'); d.className='muted'; d.textContent='No boats in use. Click "Reset boats" to restore defaults.'; wrap.appendChild(d); return; }
  boats.forEach((b,idx)=>{
    const box=document.createElement('div'); box.className='boat';
    box.innerHTML=`
      <div class="just">
        <div><h4>${idx+1}. ${b.name} ${b.toilet?'ðŸš»':''}</h4><small class="muted">${b.seats} seats${b.toilet?', toilet':''}</small></div>
        <div class="row" style="gap:6px;flex-wrap:nowrap">
          <button class="btn" data-act="up" data-idx="${idx}" title="Earlier">â–²</button>
          <button class="btn" data-act="down" data-idx="${idx}" title="Later">â–¼</button>
          <button class="btn btn-danger" data-act="remove" data-idx="${idx}" title="Remove boat">Ã—</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <label class="row" style="align-items:center;gap:6px;flex:0 0 auto">
          <input type="checkbox" data-act="ddi" data-idx="${idx}" ${b.tagDDI?'checked':''}/> DDI
        </label>
        <label class="row" style="align-items:center;gap:6px;flex:0 0 auto">
          <input type="checkbox" data-act="fly" data-idx="${idx}" ${b.tagFly?'checked':''}/> Fly-Raft
        </label>
        <label class="row" style="align-items:center;gap:6px;flex:0 0 auto">
          <input type="checkbox" data-act="ee" data-idx="${idx}" ${b.tagEE?'checked':''}/> EE
        </label>
        <label class="row" style="align-items:center;gap:6px;flex:0 0 auto">
          <input type="checkbox" data-act="wh" data-idx="${idx}" ${b.tagWH?'checked':''}/> WH
        </label>
        <div class="row" style="flex:1 1 auto;gap:6px;justify-content:flex-end">
          <label style="flex:0 0 150px">Hold seats
            <input type="number" data-act="hold" data-idx="${idx}" min="0" max="${b.seats}" value="${b.hold||0}" />
          </label>
        </div>
      </div>
    `;
    wrap.appendChild(box);
  });
  wrap.querySelectorAll('button').forEach(btn=>{
    btn.onclick=()=>{
      const idx=+btn.dataset.idx, act=btn.dataset.act;
      if(act==='up'&&idx>0){ [boats[idx-1],boats[idx]]=[boats[idx],boats[idx-1]]; renderBoats(); }
      if(act==='down'&&idx<boats.length-1){ [boats[idx+1],boats[idx]]=[boats[idx],boats[idx+1]]; renderBoats(); }
      if(act==='remove'){ boats.splice(idx,1); renderBoats(); setStatus('Boat removed.'); }
    };
  });
  wrap.querySelectorAll('input').forEach(inp=>{
    inp.onchange=()=>{
      const idx=+inp.dataset.idx, act=inp.dataset.act;
      if(act==='ddi'){ boats[idx].tagDDI = inp.checked; if(inp.checked && boats[idx].tagFly){ boats[idx].tagFly=false; } }
      if(act==='fly'){ boats[idx].tagFly = inp.checked; if(inp.checked && boats[idx].tagDDI){ boats[idx].tagDDI=false; } }
      if(act==='ee'){ boats[idx].tagEE = inp.checked; }
      if(act==='wh'){ boats[idx].tagWH = inp.checked; }
      if(act==='hold'){
        let v=parseInt(inp.value||'0',10); v=isNaN(v)?0:v; v=Math.max(0,Math.min(v,boats[idx].seats)); boats[idx].hold=v; inp.value=String(v);
      }
      renderBoats(); // re-render to reflect mutual exclusion cleanly
    };
  });
}

/* Allocation */
function allocate(){
  clearMsgs();
  if(!rows.length){ setStatus('Please upload a CSV first.'); return; }
  if(!boats.length){ setStatus('No boats in use. Click "Reset boats".'); return; }

  // Build boats
  const B = boats.map(b=>({
    name:b.name,seats:b.seats,toilet:b.toilet,
    tagDDI:!!b.tagDDI, tagFly:!!b.tagFly, tagEE:!!b.tagEE, tagWH:!!b.tagWH,
    hold: Math.max(0,Math.min(b.hold||0,b.seats)),
    pax:[], count:0
  }));
  const eff = b => Math.max(0,b.seats-b.hold);
  const edges = edgeOrder(B.length);         // [0, last, 1, last-1, ...]
  const lastIdx = edges[1] ?? (B.length-1);
  const secondLastIdx = Math.max(0, B.length-2);
  const edgeBoats = edges.map(i=>({i,b:B[i]}));
  const tagOrder = tag => edgeBoats.filter(o=>o.b[`tag${tag}`]).sort((a,b)=>edges.indexOf(a.i)-edges.indexOf(b.i));

  // Sections
  const distinct = [...new Set(rows.map(r=>r.timeMins).filter(v=>v!=null))].sort((a,b)=>a-b);
  rows.forEach(r=>r.section = quartileSection(r.timeMins, distinct));

  // Helpers
  function addPax(i,r,tags=[],hl=[]){ const need=r.num||1; const b=B[i]; b.pax.push({row:r,count:need,tags:new Set(tags),highlights:new Set(hl)}); b.count+=need; }
  const boatOf = row => { for(let i=0;i<B.length;i++){ if(B[i].pax.some(p=>p.row===row)) return i; } return -1; };
  function sectionEdgeOrder(section){
    if(section==='1st'||section==='2nd'){ const wl = edges.filter(i=>i!==lastIdx); return [...wl,lastIdx]; }
    return edges;
  }

  // Matchers
  const isDDI   = r => /daydream\s*island/i.test(r.pu);
  const isOwn   = r => /(own\s*way|tbc|not\s*sure)/i.test(r.pu);
  const isEE    = r => /\bee\b/i.test(r.notes||'');
  const noteFly = r => /(fly[-\s]*raft|fly\s*raft)/i.test(r.notes||'');
  const hasFR   = r => /\(\s*F\s*\+\s*R\s*\)/i.test(r.clientRaw) || r.flyFromCount || noteFly(r);
  const earlyBoat = r => /early\s*boat/i.test(r.notes||'');
  const infant  = r => /infant/i.test(r.notes||'');
  const charter = r => /charter/i.test(r.pu)||/charter/i.test(r.notes||'');
  const wHoldName = r => /\bweather\s*hold\b/i.test(r.clientRaw);

  // Filter
  const filtered = rows.filter(r=>!wHoldName(r) && !charter(r));
  const unassigned = new Set(filtered);

  // ---- DDI first (only DDI-tagged boats) ----
  let ddiBoats = tagOrder('DDI');
  const ddiRows = filtered.filter(isDDI);
  if(ddiRows.length && ddiBoats.length===0 && B.length){
    B[0].tagDDI = true; ddiBoats = tagOrder('DDI'); pushMsg('Auto-tagged earliest boat as DDI.','warn');
  }
  for(const r of ddiRows){
    if(!unassigned.has(r)) continue; const need=r.num||1;
    for(const {i} of ddiBoats){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,['DDI']); unassigned.delete(r); break; } }
  }

  // ---- F+R strict rule: only Fly boats (latest preferred), else overflow to second-last non-DDI ----
  const flyRows = filtered.filter(r=>hasFR(r) && !earlyBoat(r))
    .sort((a,b)=>{
      const rank = s => ({'Unknown':0,'4th':1,'3rd':2,'2nd':3,'1st':4}[s] ?? 5);
      const ra=rank(a.section), rb=rank(b.section); if(ra!==rb) return ra-rb;
      return (b.timeMins??-1)-(a.timeMins??-1);
    });

  let flyBoats = tagOrder('Fly'); // earliestâ†’latest along edges
  if(flyRows.length && flyBoats.length===0){
    B[lastIdx].tagFly = true; flyBoats = tagOrder('Fly'); pushMsg('No Fly boat tagged â€” auto-tagged latest boat.','warn');
  }
  const flyLatestFirst = flyBoats.slice().reverse();

  function overflowForFly(cnt){
    // Prefer second-last, but never a DDI boat; else nearest late non-DDI that fits
    const candidates = [];
    if(secondLastIdx!==lastIdx) candidates.push(secondLastIdx);
    for(let i=B.length-3;i>=0;i--) candidates.push(i);
    for(const i of candidates){ const b=B[i]; if(b.tagDDI) continue; if(b.count+cnt<=eff(b)) return i; }
    return null;
  }

  for(const r of flyRows){
    if(!unassigned.has(r)) continue; const need=r.num||1;
    const order = (r.section==='Unknown'||r.section==='4th'||r.section==='3rd') ? flyLatestFirst : flyBoats;
    let placed=false;
    for(const {i} of order){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,['F+R']); unassigned.delete(r); placed=true; break; } }
    if(!placed){
      const over = overflowForFly(need);
      if(over!=null){ addPax(over,r,['F+R'],['Fly-Raft overflow']); unassigned.delete(r); }
      else pushMsg(`F+R "${r.clientRaw}" could not find Fly/overflow capacity.`, 'bad');
    }
  }

  // ---- EE: keep early if >=3 boats & room; otherwise latest EE or last ----
  let eeBoats = tagOrder('EE');
  const eeRows = filtered.filter(isEE);
  for(const r of eeRows){
    if(!unassigned.has(r)) continue; const need=r.num||1;
    const earlyEE = (r.section==='1st'||r.section==='2nd');
    if(earlyEE && B.length>=3){
      let placed=false;
      for(const i of sectionEdgeOrder(r.section)){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,['EE']); placed=true; break; } }
      if(placed){ unassigned.delete(r); continue; }
    }
    let placed=false;
    const eeLate = eeBoats.length ? eeBoats.slice().reverse() : [{i:lastIdx}];
    for(const {i} of eeLate){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,['EE'],[earlyEE?'Early EE moved later':'']); placed=true; break; } }
    if(!placed){ for(const {i} of edgeBoats){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,['EE'],['EE by capacity']); placed=true; break; } } }
    if(placed) unassigned.delete(r);
  }

  // ---- MAP (south only) simple grouping ----
  const isSouth = el('tour').value==='south';
  function hasMAP(row){ return /\*MAP\*/i.test(row.clientRaw); }
  if(isSouth){
    const mrows = filtered.filter(hasMAP).filter(r=>unassigned.has(r));
    let anchor=null;
    for(const r of mrows){
      const need=r.num||1; let placed=false;
      const scan = anchor!=null?[{i:anchor}]:edgeBoats;
      for(const {i} of scan){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,['MAP']); unassigned.delete(r); anchor=i; placed=true; break; } }
      if(!placed){ for(const {i} of edgeBoats){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,['MAP'],['*MAP* fallback']); unassigned.delete(r); anchor=i; break; } } }
    }
  }

  // ---- Infant â†’ prefer big boats ----
  const infantRows = filtered.filter(r=>infant(r) && unassigned.has(r));
  if(infantRows.length){
    const pref = B.map((b,i)=>({i,b})).sort((a,b)=>(b.b.seats===32)-(a.b.seats===32)||(b.b.toilet?1:0)-(a.b.toilet?1:0)||edges.indexOf(a.i)-edges.indexOf(b.i));
    for(const r of infantRows){
      const need=r.num||1; let placed=false;
      for(const {i} of pref){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,['Infant']); unassigned.delete(r); placed=true; break; } }
      if(!placed){ for(const {i} of edgeBoats){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,['Infant'],['Infant fallback']); unassigned.delete(r); break; } } }
    }
  }

  // ---- Own way / TBC / not sure â†’ later bias ----
  for(const r of filtered.filter(r=>isOwn(r) && unassigned.has(r))){
    const need=r.num||1;
    for(const i of edges.slice().reverse()){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,[],['Own way â†’ later']); unassigned.delete(r); break; } }
  }

  // ---- Early-boat override for F+R (explicit) â†’ earliest edge ----
  for(const r of filtered.filter(r=>earlyBoat(r)&&hasFR(r))){
    if(!unassigned.has(r)) continue; const need=r.num||1;
    for(const {i} of edgeBoats){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,[],['Early boat override (ignored F+R)']); unassigned.delete(r); break; } }
  }

  // ---- Baseline fill by section (edges-first, avoid last for early) ----
  const orderSec={'1st':0,'2nd':1,'3rd':2,'4th':3,'Unknown':4};
  [...unassigned].sort((a,b)=>{
    const da=orderSec[a.section]??4, db=orderSec[b.section]??4;
    if(da!==db) return da-db;
    return (a.timeMins??1e9)-(b.timeMins??1e9);
  }).forEach(r=>{
    const need=r.num||1; let placed=false;
    for(const i of sectionEdgeOrder(r.section)){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r); placed=true; break; } }
    if(!placed){ for(const i of edges){ const b=B[i]; if(b.count+need<=eff(b)){ addPax(i,r,[],['Capacity fallback']); break; } }
  });

  // ---- SAFETY: F+R never on DDI; F+R must be on Fly or allowed overflow ----
  (function enforceFR(){
    const flyIdx = tagOrder('Fly').map(o=>o.i);
    for(let i=0;i<B.length;i++){
      const b=B[i];
      for(let k=0;k<b.pax.length;k++){
        const p=b.pax[k];
        const isFR = p.tags.has('F+R') || /\(\s*F\s*\+\s*R\s*\)/i.test(p.row.clientRaw) || noteFly(p.row);
        if(!isFR) continue;
        if(flyIdx.includes(i)) continue; // OK (on Fly)
        if(B[i].tagDDI){ // NEVER on DDI
          const need=p.count;
          let moved=false;
          // Try latest Fly first
          for(const tgt of flyIdx.slice().reverse()){ const tb=B[tgt]; if(tb.count+need<=eff(tb)){ b.pax.splice(k,1); b.count-=need; addPax(tgt,p.row,[...p.tags],['Moved from DDI â†’ Fly']); moved=true; k--; break; } }
          // Else overflow to second-last non-DDI
          if(!moved){
            const over = overflowForFly(need);
            if(over!=null){ b.pax.splice(k,1); b.count-=need; addPax(over,p.row,[...p.tags],['Moved from DDI â†’ overflow']); k--; moved=true; }
          }
          if(!moved){ p.highlights.add('FR rule violation (no Fly/overflow capacity)'); }
          continue;
        }
        // Not DDI and not Fly â†’ try to move to Fly or overflow (to keep invariant)
        if(!flyIdx.length) continue;
        const need=p.count;
        let moved=false;
        for(const tgt of flyIdx.slice().reverse()){ const tb=B[tgt]; if(tb.count+need<=eff(tb)){ b.pax.splice(k,1); b.count-=need; addPax(tgt,p.row,[...p.tags],['Moved to Fly']); moved=true; k--; break; } }
        if(!moved){
          const over = overflowForFly(need);
          if(over!=null){ b.pax.splice(k,1); b.count-=need; addPax(over,p.row,[...p.tags],['Fly overflow']); k--; }
        }
      }
    }
  })();

  // ---- Edge fill: pack Boat #1 and Last first (respect FR rule) ----
  function tryPull(toIdx, preferLateOnly){
    const dest=B[toIdx]; if(dest.count>=eff(dest)) return false;
    const isDestFly = dest.tagFly;
    // look from middle outward (donors not equal to dest)
    const donors = edges.filter(j=>j!==toIdx).sort((a,b)=>{
      const mid=(B.length-1)/2; const da=Math.abs(a-mid), db=Math.abs(b-mid); return db-da || a-b;
    });
    for(const j of donors){
      const src=B[j];
      for(let k=0;k<src.pax.length;k++){
        const p=src.pax[k];
        const isFR = p.tags.has('F+R') || /\(\s*F\s*\+\s*R\s*\)/i.test(p.row.clientRaw) || noteFly(p.row);
        // never pull F+R into non-Fly destinations
        if(isFR && !isDestFly) continue;
        if(preferLateOnly && !['Unknown','4th','3rd'].includes(p.row.section)) continue;
        if(dest.count + p.count <= eff(dest)){
          src.pax.splice(k,1); src.count-=p.count; addPax(toIdx,p.row,[...p.tags],[...p.highlights,'Edge fill']); return true;
        }
      }
    }
    return false;
  }
  for(const idx of [edges[0], edges[1]].filter(v=>v!=null)){ let ch=true; while(ch){ ch=tryPull(idx,true); } }
  for(const idx of [edges[0], edges[1]].filter(v=>v!=null)){ let ch=true; while(ch){ ch=tryPull(idx,false); } }

  // ---- Micro-pack: if Boat #1 still has gap, move any suitable non-FR, non-DDI from middle ----
  (function topUpFirst(){
    const first=B[0]; if(!first) return;
    for(let guard=0; guard<200 && first.count<eff(first); guard++){
      let moved=false;
      for(const j of edges.slice(1)){ const src=B[j];
        for(let k=0;k<src.pax.length;k++){
          const p=src.pax[k];
          const isFR = p.tags.has('F+R') || /\(\s*F\s*\+\s*R\s*\)/i.test(p.row.clientRaw) || noteFly(p.row);
          const isDDI = p.tags.has('DDI');
          if(isFR||isDDI) continue;
          if(first.count + p.count <= eff(first)){
            src.pax.splice(k,1); src.count-=p.count; addPax(0,p.row,[...p.tags],[...p.highlights,'Top-up Boat #1']); moved=true; break;
          }
        }
        if(moved) break;
      }
      if(!moved) break;
    }
  })();

  // ---- Output ----
  const out=[["Boat","DepartureOrder","Boat Hold Seats","Boat Tags","Client","No. Pass.","P/U Point","Time","Pickup Notes","Phone","Tags","Highlights","Pickup Section"]];
  const results = el('results'); results.innerHTML='';
  let total=0, cap=0;

  B.forEach((b,idx)=>{
    total+=b.count; cap+=eff(b);
    const boatTags=[b.tagDDI?'DDI':'', b.tagFly?'Fly-Raft':'', b.tagEE?'EE':'', b.tagWH?'WH':''].filter(Boolean).join('; ');
    const head=document.createElement('div');
    head.style.margin='8px 0 6px';
    head.innerHTML = `<div class="just">
      <div><b>${idx+1}. ${b.name}</b> &nbsp; <span class="pill ${b.count<=eff(b)?'ok':'bad'}">${b.count}/${eff(b)}</span></div>
      <div class="chips">
        ${b.tagDDI?'<span class="chip">DDI</span>':''}
        ${b.tagFly?'<span class="chip">Fly-Raft</span>':''}
        ${b.tagEE?'<span class="chip">EE</span>':''}
        ${b.tagWH?'<span class="chip">WH</span>':''}
        ${b.hold?`<span class="chip">Hold: ${b.hold}</span>`:''}
        ${b.toilet?'<span class="chip">ðŸš»</span>':''}
      </div>
    </div>`;
    results.appendChild(head);

    const table=document.createElement('table');
    table.innerHTML = `<thead><tr>
      <th>#</th><th>Client</th><th>No. Pass.</th><th>P/U Point</th><th>Time</th><th>Section</th><th>Tags</th><th>Highlights</th>
    </tr></thead>`;
    const tb=document.createElement('tbody');
    b.pax.forEach((p,i)=>{
      const tags=[...p.tags], hl=[...p.highlights];
      const tr=document.createElement('tr');
      tr.innerHTML = `
        <td>${i+1}</td>
        <td>${escapeHtml(p.row.clientRaw)}</td>
        <td>${p.count}</td>
        <td>${escapeHtml(p.row.pu)}</td>
        <td>${p.row.time||''}</td>
        <td>${p.row.section}</td>
        <td>${tags.map(t=>`<span class="pill tag">${t}</span>`).join(' ')}</td>
        <td>${hl.filter(Boolean).map(t=>`<span class="pill warn">${escapeHtml(t)}</span>`).join(' ')}</td>
      `;
      tb.appendChild(tr);
      out.push([b.name,idx+1,b.hold,boatTags,p.row.clientRaw,p.count,p.row.pu,p.row.time||'',p.row.notes||'',p.row.phone||'',tags.join('; '),hl.filter(Boolean).join('; '),p.row.section]);
    });
    table.appendChild(tb);
    results.appendChild(table);
  });

  const summary=document.createElement('div'); summary.className='status';
  summary.innerHTML = `Total allocated: <b>${total}</b> / Effective capacity: <b>${cap}</b>${total>cap?' <span class="pill bad">Over capacity</span>':''}`;
  results.prepend(summary);

  // CSV download
  const csv = toCSV(out); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob);
  const dl=el('download'); dl.onclick=()=>{ const stamp=new Date().toISOString().slice(0,10); const a=document.createElement('a'); a.href=url; a.download=`boat-split-${el('tour').value}-${stamp}.csv`; document.body.appendChild(a); a.click(); a.remove(); };
  dl.disabled=false;
  setStatus('Allocation complete.');
}

/* Wiring */
function wire(){
  el('resetBoats').onclick=()=>{ boats=cloneBoats(); renderBoats(); setStatus('Boats reset.'); };
  el('run').onclick=allocate;
  el('file').addEventListener('change', async e=>{
    clearMsgs();
    const f=e.target.files?.[0]; if(!f) return;
    const text = await f.text();
    const raw = parseCSV(text);
    if(!raw.length){ setStatus('Empty CSV.'); return; }
    const header = raw[0].map(h=>h.trim());
    const data = raw.slice(1);

    const idxClient=findColIndex(header,COL_ALIASES.client);
    const idxNum   =findColIndex(header,COL_ALIASES.num);
    const idxPU    =findColIndex(header,COL_ALIASES.pu);
    const idxTime  =findColIndex(header,COL_ALIASES.time);
    const idxNotes =findColIndex(header,COL_ALIASES.notes);
    const idxPhone =findColIndex(header,COL_ALIASES.phone);

    if(idxClient<0 || idxPU<0){ setStatus('Missing required columns: need at least Client and P/U Point.'); return; }

    rows = data.map(r=>{
      const clientRaw = norm(r[idxClient]);
      const numRaw = (r[idxNum]??'').toString();
      // F+R detection anywhere
      const FRfromCount  = /\(\s*F\s*\+\s*R\s*\)/i.test(numRaw);
      const FRfromClient = /\(\s*F\s*\+\s*R\s*\)/i.test(clientRaw);
      const FRfromNotes  = /\(\s*F\s*\+\s*R\s*\)/i.test(norm(idxNotes>=0?r[idxNotes]:'')); 
      const flyFromAny   = FRfromCount || FRfromClient || FRfromNotes;

      const numMatch = numRaw.match(/\d+/);
      const num = Math.max(1, numMatch ? parseInt(numMatch[0],10) : 1);

      const pu   = norm(r[idxPU]);
      const time = norm(idxTime>=0?r[idxTime]:'');
      const notes= norm(idxNotes>=0?r[idxNotes]:'');
      const phone= norm(idxPhone>=0?r[idxPhone]:'');
      const timeMins = parseTimeToSortable(time);

      return { clientRaw, num, pu, time, timeMins, notes, phone, flyFromCount: flyFromAny };
    }).filter(r=>!/\bweather\s*hold\b/i.test(r.clientRaw)); // drop WEATHER HOLD rows entirely

    el('results').innerHTML=''; el('download').disabled=true;
    setStatus(`Loaded ${rows.length} rows. Configure boats & holds, then Allocate.`);
  });
}

function init(){ boats=cloneBoats(); renderBoats(); wire(); setStatus('No file loaded. (v=fr-guard2)'); }
document.readyState==='loading' ? document.addEventListener('DOMContentLoaded',init) : init();
</script>
</body>
</html>
