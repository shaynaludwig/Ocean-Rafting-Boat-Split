<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Boat Split</title>
<style>
  :root { --bg:#0f172a; --card:#111827; --text:#e5e7eb; --muted:#93a3b5; --chip:#1f2937; }
  *{box-sizing:border-box}
  body{margin:0;background:#0b1222;color:#e5e7eb;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:24px 16px;text-align:center;background:linear-gradient(180deg,#0b1222,#0a0f1c)}
  header h1{margin:0;font-size:28px}
  header p{margin:6px 0 0;color:#9ca3af}
  .container{max-width:1600px;margin:0 auto;padding:16px}
  .grid{display:grid;gap:16px;grid-template-columns:1fr}
  @media(min-width:1200px){.grid{grid-template-columns:420px 1fr}}
  .card{background:radial-gradient(900px 450px at 120% 0,rgba(167,139,250,.08),transparent 45%),var(--card);border:1px solid #1f2937;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
  .section-title{font-weight:700;margin:0 0 12px;font-size:15px;letter-spacing:.3px;text-transform:uppercase;color:#cbd5e1}
  label{display:block;font-size:14px;color:#cbd5e1;margin:10px 0 6px}
  select,input[type="text"],input[type="number"]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid #263142;background:#0b1220;color:#e5e7eb}
  input[type="file"]{width:100%}
  .row{display:flex;gap:10px;flex-wrap:wrap}.row>*{flex:1 1 150px}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:12px;border:1px solid #263142;background:#0b1220;color:#fff;cursor:pointer;text-decoration:none}
  .btn:hover{border-color:#334155}
  .btn-primary{background:#12243c;border-color:#1e3a5f}
  .btn-accent{background:#0c2430;border-color:#124657}
  .btn-danger{background:#2a0f14;border-color:#5b1c25}
  .btn-icon{padding:6px 9px;border-radius:8px}
  .chips{display:flex;flex-wrap:wrap;gap:8px;margin-top:8px}.chip{background:var(--chip);border:1px solid #243042;color:#d1d5db;padding:6px 10px;border-radius:999px;font-size:12px}
  .muted{color:var(--muted);font-size:13px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px 8px;border-bottom:1px solid #1f2937;text-align:left;font-size:13px}
  th{font-weight:700;color:#cbd5e1;position:sticky;top:0;background:#0e1626}
  .pill{display:inline-block;font-size:11px;padding:4px 8px;border-radius:999px;border:1px solid #1f2937}
  .ok{background:rgba(22,163,74,.15);border-color:rgba(22,163,74,.4)}
  .warn{background:rgba(245,158,11,.12);border-color:rgba(245,158,11,.4)}
  .bad{background:rgba(239,68,68,.12);border-color:rgba(239,68,68,.4)}
  .tag{background:rgba(34,211,238,.12);border-color:rgba(34,211,238,.4);color:#a5f3fc}
  .boats{display:grid;gap:10px;grid-template-columns:1fr}
  @media(min-width:640px){.boats{grid-template-columns:1fr 1fr}}
  @media(min-width:1024px){.boats{grid-template-columns:1fr 1fr 1fr}}
  @media(min-width:1440px){.boats{grid-template-columns:1fr 1fr 1fr 1fr}}
  .boat{border:1px solid #1f2937;border-radius:12px;padding:12px;background:#0b1220}
  .boat h4{margin:0 0 8px;font-size:15px}
  .boat small{color:#9ca3af}
  .justify{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .flex{display:flex;align-items:center;gap:8px}
  .statusline{margin:8px 0 12px;font-size:13px;color:#b6c2d0}
  .footer{text-align:center;color:#64748b;font-size:12px;padding:24px 12px 40px}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
</style>
</head>
<body>
<header>
  <h1>Boat Split</h1>
  <p>Upload CSV ‚Üí set tour ‚Üí remove boats with ‚Äú√ó‚Äù ‚Üí tag boats & holds ‚Üí Allocate ‚Üí Download CSV</p>
</header>

<div class="container grid">
  <!-- LEFT -->
  <div class="card">
    <div class="section-title">1) Upload CSV</div>
    <input type="file" id="file" accept=".csv" />
    <div class="muted" style="margin-top:6px">
      Expected columns: <span class="chip mono">Client</span>
      <span class="chip mono">No. Pass.</span>
      <span class="chip mono">P/U Point</span>
      <span class="chip mono">Time</span>
      <span class="chip mono">Pickup Notes</span>
      <span class="chip mono">Phone</span>
    </div>

    <div class="section-title" style="margin-top:18px">2) Tour & Options</div>
    <label for="tour">Tour</label>
    <select id="tour">
      <option value="north">Northern</option>
      <option value="south">Southern</option>
    </select>

    <label style="margin-top:16px">Pickup Sectioning</label>
    <div class="muted">Times split into quartiles ‚Üí <span class="chip">1st</span> <span class="chip">2nd</span> <span class="chip">3rd</span> <span class="chip">4th</span></div>

    <div class="section-title" style="margin-top:18px">3) Boats & Departure Order</div>
    <div class="muted" style="margin-bottom:6px">
      Reorder (‚ñ≤/‚ñº), tag (DDI / Fly-Raft / EE / <b>WH</b>), set <b>Hold seats</b>, or remove with <b>√ó</b>. Reset brings all back.
    </div>
    <div id="boats" class="boats"></div>

    <div style="margin-top:14px; display:flex; gap:8px; flex-wrap:wrap">
      <button id="resetBoats" class="btn">Reset boats</button>
      <button id="run" class="btn btn-primary">Allocate</button>
      <button id="download" class="btn btn-accent" disabled>Download CSV</button>
    </div>
    <div class="chips" id="messages"></div>
  </div>

  <!-- RIGHT -->
  <div class="card">
    <div class="section-title">Results</div>
    <div class="statusline" id="status">No file loaded. (v=edge-ee7)</div>
    <div id="results"></div>
  </div>
</div>

<div class="footer">
  Exported CSV adds <span class="mono">Boat Hold Seats</span> and <span class="mono">Boat Tags</span>. On-screen rows are colour-coded.
</div>

<script>
// show live errors on page
window.onerror = function (msg, src, line, col, err) {
  const pre = document.createElement('pre');
  pre.style.cssText = 'white-space:pre-wrap;background:#3b0f0f;color:#ffecec;padding:10px;border:1px solid #7f1d1d;border-radius:8px;margin:10px';
  pre.textContent =
    'Script error:\n' + msg + '\n' +
    (src ? ('at ' + src + ':' + line + ':' + col + '\n') : '') +
    (err && err.stack ? err.stack : '');
  document.body.prepend(pre);
};

/* ---------- defaults ---------- */
const DEFAULT_BOATS = [
  { name: "Joyride", seats: 32, toilet: true },
  { name: "Thunderstruck", seats: 32, toilet: true },
  { name: "Black Betty", seats: 32, toilet: true },
  { name: "Wipeout", seats: 32, toilet: true },
  { name: "Riptide", seats: 32, toilet: true },
  { name: "Thrilla", seats: 25, toilet: false },
  { name: "Jammin", seats: 22, toilet: true },
  { name: "Wildthing", seats: 19, toilet: false },
];

let rows=[], boats=[];

const fileInput = document.getElementById('file');
const tourSelect = document.getElementById('tour');
const boatsDiv = document.getElementById('boats');
const runBtn = document.getElementById('run');
const resetBtn = document.getElementById('resetBoats');
const downloadBtn = document.getElementById('download');
const statusEl = document.getElementById('status');
const resultsEl = document.getElementById('results');
const messagesEl = document.getElementById('messages');

function setStatus(s){ statusEl.textContent=s; }
function clearMsgs(){ messagesEl.innerHTML=''; }
function pushMsg(text,tone=''){ const m=document.createElement('span'); m.className='chip'; if(tone==='ok')m.style.borderColor='rgba(22,163,74,.5)'; if(tone==='warn')m.style.borderColor='rgba(245,158,11,.5)'; if(tone==='bad')m.style.borderColor='rgba(239,68,68,.5)'; m.textContent=text; messagesEl.appendChild(m); }
function escapeHtml(s){ return (s??'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }
function cloneBoats(){ return DEFAULT_BOATS.map(b=>({...b, tagDDI:false, tagFly:false, tagEE:false, tagWH:false, hold:0 })); }
function norm(s){ return (s||'').trim(); }
function ownNamePortion(clientRaw){ return norm(clientRaw.split(/\*(?:TW|MAP)\*/i)[0]); }
function normalizeFull(name){
  let s = norm(name);
  s = s.replace(/\(\s*F\s*\+\s*R\s*\)/ig, ''); // drop (F+R) from identity
  s = s.replace(/\s+/g,' ');
  return s.toLowerCase();
}
function edgeOrder(n){ const res=[]; for(let a=0,b=n-1;a<=b;a++,b--){ res.push(a); if(b>a) res.push(b);} return res; }

/* csv helpers */
function parseCSV(text){
  const rows=[]; let cur='',row=[],inQ=false,i=0;
  while(i<text.length){ const ch=text[i];
    if(inQ){ if(ch==='"'){ if(text[i+1]==='"'){cur+='"';i+=2;continue} inQ=false;i++;continue } cur+=ch; i++; continue; }
    if(ch==='"'){ inQ=true; i++; continue; }
    if(ch===','){ row.push(cur); cur=''; i++; continue; }
    if(ch==='\r'){ i++; continue; }
    if(ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=''; i++; continue; }
    cur+=ch; i++;
  }
  row.push(cur); rows.push(row);
  if(rows.length && rows[rows.length-1].every(c=>c==='')) rows.pop();
  return rows;
}
function toCSV(rows){ const esc=s=>{ if(s==null)return''; s=String(s); return /[",\n]/.test(s)?'"'+s.replace(/"/g,'""')+'"':s; }; return rows.map(r=>r.map(esc).join(',')).join('\n'); }
const COL_ALIASES = {
  client:["client","name","full name","passenger","pax name"],
  num:["no. pass.","no pass","passengers","pax","qty","count"],
  pu:["p/u point","pickup point","p/u","pick up","pickup","location"],
  time:["time","pickup time","p/u time"],
  notes:["pickup notes","notes","comments","pu comments","p/u notes"],
  phone:["phone","mobile"]
};
function findColIndex(h,keys){
  const lower=h.map(x=>x.toLowerCase());
  for(const k of keys){ const i=lower.indexOf(k); if(i!==-1) return i; }
  for(let i=0;i<lower.length;i++){ if(keys.some(k=>lower[i].includes(k))) return i; }
  return -1;
}
function parseTimeToSortable(t){
  if(!t) return null; let s=t.toString().trim(); if(!s) return null;
  s=s.replace('.',':'); const ampm=/am|pm/i.test(s)?s.match(/am|pm/i)[0].toLowerCase():null;
  s=s.replace(/[^0-9:]/g,''); if(/^\d{3,4}$/.test(s)){ s=(s.length===3?'0'+s:s); s=s.slice(0,2)+':'+s.slice(2); }
  if(!/^\d{1,2}:\d{2}$/.test(s)) return null;
  let [hh,mm]=s.split(':').map(n=>parseInt(n,10)); if(ampm){ if(ampm==='pm'&&hh<12)hh+=12; if(ampm==='am'&&hh===12)hh=0; }
  if(hh>=0&&hh<24&&mm>=0&&mm<60) return hh*60+mm; return null;
}
function quartileSection(mins, sortedDistinct){
  if(mins==null) return 'Unknown'; const n=sortedDistinct.length; if(!n) return 'Unknown';
  const q1=sortedDistinct[Math.floor(n*.25)], q2=sortedDistinct[Math.floor(n*.50)], q3=sortedDistinct[Math.floor(n*.75)];
  if(mins<=q1) return '1st'; if(mins<=q2) return '2nd'; if(mins<=q3) return '3rd'; return '4th';
}

/* boats UI */
function renderBoats(){
  boatsDiv.innerHTML = '';
  if(!boats.length){
    const empty=document.createElement('div'); empty.className='muted'; empty.textContent='No boats in use. Click "Reset boats" to restore defaults.'; boatsDiv.appendChild(empty); return;
  }
  boats.forEach((b,idx)=>{
    const el=document.createElement('div'); el.className='boat';
    el.innerHTML = `
      <div class="justify">
        <div>
          <h4>${idx+1}. ${b.name} ${b.toilet?'üöª':''}</h4>
          <small>${b.seats} seats${b.toilet?', toilet':''}</small>
        </div>
        <div class="flex">
          <button class="btn btn-icon" data-act="up" data-idx="${idx}" title="Earlier">‚ñ≤</button>
          <button class="btn btn-icon" data-act="down" data-idx="${idx}" title="Later">‚ñº</button>
          <button class="btn btn-danger btn-icon" data-act="remove" data-idx="${idx}" title="Remove this boat">√ó</button>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <label class="flex"><input type="checkbox" data-act="ddi" data-idx="${idx}" ${b.tagDDI?'checked':''}/> DDI</label>
        <label class="flex"><input type="checkbox" data-act="fly" data-idx="${idx}" ${b.tagFly?'checked':''}/> Fly-Raft</label>
        <label class="flex"><input type="checkbox" data-act="ee"  data-idx="${idx}" ${b.tagEE?'checked':''}/> EE</label>
        <label class="flex"><input type="checkbox" data-act="wh"  data-idx="${idx}" ${b.tagWH?'checked':''}/> WH (Weather Hold)</label>
      </div>
      <div class="row" style="margin-top:6px">
        <div>
          <label>Hold seats</label>
          <input type="number" data-act="hold" data-idx="${idx}" min="0" max="${b.seats}" value="${b.hold||0}" />
        </div>
      </div>
    `;
    boatsDiv.appendChild(el);
  });
  boatsDiv.querySelectorAll('button').forEach(btn=>{
    btn.addEventListener('click',()=>{
      const idx=+btn.dataset.idx, act=btn.dataset.act;
      if(act==='up'&&idx>0){ [boats[idx-1],boats[idx]]=[boats[idx],boats[idx-1]]; renderBoats(); }
      if(act==='down'&&idx<boats.length-1){ [boats[idx+1],boats[idx]]=[boats[idx],boats[idx+1]]; renderBoats(); }
      if(act==='remove'){ boats.splice(idx,1); renderBoats(); setStatus('Boat removed for this tour.'); }
    });
  });
  boatsDiv.querySelectorAll('input').forEach(inp=>{
    inp.addEventListener('change',()=>{
      const idx=+inp.dataset.idx, act=inp.dataset.act;
      if(act==='ddi') boats[idx].tagDDI = inp.checked;
      if(act==='fly') boats[idx].tagFly = inp.checked;
      if(act==='ee')  boats[idx].tagEE  = inp.checked;
      if(act==='wh')  boats[idx].tagWH  = inp.checked;
      if(act==='hold'){
        let v = parseInt(inp.value||'0',10);
        v = isNaN(v)?0:v;
        v = Math.max(0, Math.min(v, boats[idx].seats));
        boats[idx].hold = v;
        inp.value = String(v);
      }
    });
  });
}

/* allocation */
function allocate(){
  clearMsgs();
  if(!rows.length){ setStatus('Please upload a CSV first.'); return; }
  if(!boats.length){ setStatus('No boats in use. Click "Reset boats" or add boats.'); return; }

  const boatList = boats.map(b=>({
    name:b.name, seats:b.seats, toilet:b.toilet,
    tagDDI:!!b.tagDDI, tagFly:!!b.tagFly, tagEE:!!b.tagEE, tagWH:!!b.tagWH,
    hold: Math.max(0, Math.min(b.hold||0, b.seats)),
    pax:[], count:0
  }));
  const effSeats = (b)=> Math.max(0, b.seats - b.hold);
  const edgeIdx = edgeOrder(boatList.length);
  const lastIdx = edgeIdx[1] ?? (boatList.length-1);
  const edgeBoats = edgeIdx.map(i=>({i,b:boatList[i]}));
  const orderByEdges = (arr)=> arr.sort((a,b)=> edgeIdx.indexOf(a.i)-edgeIdx.indexOf(b.i));
  const taggedEdgeOrder = (tag)=> orderByEdges(boatList.map((b,i)=>({i,b})).filter(o=>o.b[`tag${tag}`]));

  // For early sections, avoid using last boat until necessary
  function sectionEdgeOrder(section){
    if(section==='1st' || section==='2nd'){
      const withoutLast = edgeIdx.filter(i=>i!==lastIdx);
      return [...withoutLast, lastIdx];
    }
    return edgeIdx;
  }

  const validTimes=[...new Set(rows.map(r=>r.timeMins).filter(v=>v!=null))].sort((a,b)=>a-b);
  rows.forEach(r=>r.section=quartileSection(r.timeMins,validTimes));

  function addPax(i,r,extraTags=[],hl=[]){const need=r.num||1;const b=boatList[i];b.pax.push({row:r,count:need,tags:new Set(extraTags),highlights:new Set(hl)});b.count+=need}
  const boatIndexOfRow=(row)=>{for(let i=0;i<boatList.length;i++){if(boatList[i].pax.some(p=>p.row===row))return i}return -1};
  const removeRowFromBoats=(row)=>{for(let i=0;i<boatList.length;i++){const idx=boatList[i].pax.findIndex(p=>p.row===row);if(idx!==-1){const p=boatList[i].pax[idx];boatList[i].pax.splice(idx,1);boatList[i].count-=p.count;return i}}return -1};

  // matchers
  const isDDI=r=>/daydream\s*island/i.test(r.pu);
  const isOwnWay=r=>/(own\s*way|tbc|not\s*sure)/i.test(r.pu);
  const isEE=r=>/\bee\b/i.test(r.notes||'');
  const isFlyNotes=r=>/(fly[-\s]*raft|fly\s*raft)/i.test(r.notes||'');
  const hasFRAnywhere=r=>/\(\s*F\s*\+\s*R\s*\)/i.test(r.clientRaw) || r.flyFromCount || isFlyNotes(r);
  const isEarlyBoat=r=>/early\s*boat/i.test(r.notes||'');
  const isInfant=r=>/infant/i.test(r.notes||'');
  const multiPickupInNotes=r=>/(pickup|p\/u|pick\s*up).*(;|,|\/|\band\b).*(pickup|p\/u|pick\s*up)/i.test(r.notes||'')||/(\bETA\b.*\bETA\b)/i.test(r.notes||'');
  const isCharter=r=>/charter/i.test(r.pu)||/charter/i.test(r.notes||'');
  const isWeatherHoldName = r => /\bweather\s*hold\b/i.test(r.clientRaw);

  rows.forEach(r=>{
    r.flags=[];
    if(multiPickupInNotes(r)) r.flags.push('Multiple pickup locations noted');
    if(isCharter(r)) r.flags.push('Suspected charter (excluded)');
    r.clientOwn = ownNamePortion(r.clientRaw);
    r.fullNorm  = normalizeFull(r.clientOwn);
  });

  const filtered = rows.filter(r => !isWeatherHoldName(r) && !isCharter(r));

  // --- *TW* groups by exact full name ---
  function extractTWTargetFull(r){
    if(!/\*TW\*/i.test(r.clientRaw)) return null;
    const after = r.clientRaw.split(/\*TW\*/i).pop().trim();
    return after ? normalizeFull(after) : null;
  }
  const byFull = new Map();
  filtered.forEach(r=>{ const arr=byFull.get(r.fullNorm)||[]; arr.push(r); byFull.set(r.fullNorm,arr); });
  const twGroups = new Map(); const twAmb=[];
  filtered.forEach(r=>{
    const target = extractTWTargetFull(r);
    if(!target) return;
    const leaders = byFull.get(target)||[];
    if(leaders.length!==1){ twAmb.push(`*TW* for "${r.clientRaw}" not unique (${leaders.length}).`); return; }
    const leader=leaders[0];
    if(!twGroups.has(target)) twGroups.set(target,new Set());
    twGroups.get(target).add(r); twGroups.get(target).add(leader);
  });

  const unassigned=new Set(filtered);

  // DDI first
  const ddiRows=filtered.filter(isDDI);
  let ddiBoats=taggedEdgeOrder('DDI');
  if(ddiRows.length && ddiBoats.length===0 && boatList.length){
    boatList[0].tagDDI=true; ddiBoats=taggedEdgeOrder('DDI'); pushMsg('Auto-tagged earliest boat as DDI.','warn');
  }
  for(const r of ddiRows){
    if(!unassigned.has(r)) continue; const need=r.num||1;
    for(const {i} of ddiBoats){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,['DDI']); unassigned.delete(r); break; } }
  }

  // F+R initial placement (skip if early-boat override)
  const flyRows = filtered.filter(r => hasFRAnywhere(r) && !isEarlyBoat(r));
  let flyBoats=taggedEdgeOrder('Fly');
  const flyOrder = flyBoats.length ? flyBoats : edgeBoats;
  for(const r of flyRows){
    if(!unassigned.has(r)) continue; const need=r.num||1; let placed=false;
    for(const {i} of flyOrder){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,['F+R']); unassigned.delete(r); placed=true; break; } }
    if(!placed){ const idx=boatList.length>=2?boatList.length-2:boatList.length-1; const b=boatList[idx];
      if(b.count+need<=effSeats(b)){ addPax(idx,r,['F+R'],['Overflowed Fly-Raft ‚Üí 2nd last']); unassigned.delete(r); }
    }
  }

  // EE with early-arrival rule
  const eeRows=filtered.filter(isEE);
  let eeBoats=taggedEdgeOrder('EE');
  for(const r of eeRows){
    if(!unassigned.has(r)) continue;
    const need=r.num||1;
    const earlyEE = (r.section==='1st' || r.section==='2nd');
    if(earlyEE && boatList.length>=3){
      // keep them early if they fit (prefer edges but avoid last until needed)
      let placed=false;
      for(const i of sectionEdgeOrder(r.section)){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,['EE']); placed=true; break; } }
      if(placed){ unassigned.delete(r); continue; }
    }
    // otherwise (few boats or no room), send to late EE boat (latest tagged EE else last boat)
    let placed=false;
    const eeLateOrder = eeBoats.length ? eeBoats.slice().reverse() : [{i:lastIdx}];
    for(const {i} of eeLateOrder){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,['EE'],[earlyEE?'Early EE moved later':'']); placed=true; break; } }
    if(!placed){
      // fallback: general edge order
      for(const {i} of edgeBoats){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,['EE'],['EE placed by capacity']); placed=true; break; } }
    }
    if(placed) unassigned.delete(r);
  }

  // MAP (south only) ‚Äî edge order
  const isSouth=(tourSelect.value==='south');
  const mapGroup=filtered.filter(r=>/\*MAP\*/i.test(r.clientRaw));
  let lastMapBoat=null;
  if(isSouth && mapGroup.length){
    for(const r of mapGroup){
      if(!unassigned.has(r)) continue; const need=r.num||1; let placed=false;
      const candidates=lastMapBoat!=null?[{i:lastMapBoat}]:edgeBoats;
      for(const {i} of candidates){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,['MAP']); unassigned.delete(r); lastMapBoat=i; placed=true; break; } }
      if(!placed){ for(const {i} of edgeBoats){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,['MAP'],['*MAP* fallback']); unassigned.delete(r); lastMapBoat=i; break; } } }
    }
  }

  // Infant ‚Üí prefer big boats; tie-break by edge order
  const infantRows=filtered.filter(r=>isInfant(r) && unassigned.has(r));
  for(const r of infantRows){
    const need=r.num||1; let placed=false;
    const pref=boatList.map((b,i)=>({i,b})).sort((a,b)=>(b.b.seats===32)-(a.b.seats===32)||(b.b.toilet?1:0)-(a.b.toilet?1:0)||edgeIdx.indexOf(a.i)-edgeIdx.indexOf(b.i));
    for(const {i} of pref){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,['Infant']); unassigned.delete(r); placed=true; break; } }
    if(!placed){ for(const {i} of edgeBoats){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,['Infant'],['Infant fallback']); unassigned.delete(r); break; } } }
  }

  // Own way / TBC / not sure ‚Üí later edge side first
  const ownRows=filtered.filter(r=>isOwnWay(r) && unassigned.has(r));
  for(const r of ownRows){
    const need=r.num||1; let placed=false;
    for(const i of edgeIdx.slice().reverse()){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,[],['Own way ‚Üí later boat bias']); unassigned.delete(r); placed=true; break; } }
  }

  // Early-boat override for F+R ‚Üí earliest edge
  const earlyBoatRows=filtered.filter(r=>isEarlyBoat(r) && hasFRAnywhere(r));
  for(const r of earlyBoatRows){
    if(!unassigned.has(r)) continue; const need=r.num||1;
    for(const {i} of edgeBoats){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,[],['Early boat override (ignored F+R)']); unassigned.delete(r); break; } }
  }

  // Baseline by pickup section using section-aware edge order (avoid last for early)
  const orderBySection={'1st':0,'2nd':1,'3rd':2,'4th':3,'Unknown':4};
  [...unassigned].sort((a,b)=>{
    const oa=orderBySection[a.section]??4, ob=orderBySection[b.section]??4;
    if(oa!==ob) return oa-ob;
    return (a.timeMins??1e9)-(b.timeMins??1e9);
  }).forEach(r=>{
    const need=r.num||1; let placed=false;
    for(const i of sectionEdgeOrder(r.section)){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r); placed=true; break; } }
    if(!placed){
      for(const i of edgeIdx){ const b=boatList[i]; if(b.count+need<=effSeats(b)){ addPax(i,r,[],['Placed by capacity']); placed=true; break; } }
    }
  });

  /* ---- POST-PASS #1: F+R enforcement sweep ---- */
  const flyTagged = taggedEdgeOrder('Fly').map(o=>o.i);
  const secondLastIdx = Math.max(0, boatList.length-2);
  for(let i=0;i<boatList.length;i++){
    const b=boatList[i];
    for(let k=0;k<b.pax.length;k++){
      const p=b.pax[k];
      const isFR = p.tags.has('F+R') || /\(\s*F\s*\+\s*R\s*\)/i.test(p.row.clientRaw) || isFlyNotes(p.row);
      if(!isFR) continue;
      if(!boatList[i].tagFly && flyTagged.length){
        let moved=false;
        for(const tgt of flyTagged){
          const tb=boatList[tgt]; if(tb.count + p.count <= effSeats(tb)){
            b.pax.splice(k,1); b.count-=p.count;
            addPax(tgt,p.row,[...p.tags],['Moved to Fly-Raft boat']); moved=true; k--; break;
          }
        }
        if(!moved && i!==secondLastIdx){
          const sb=boatList[secondLastIdx];
          if(sb.count + p.count <= effSeats(sb)){
            b.pax.splice(k,1); b.count-=p.count;
            addPax(secondLastIdx,p.row,[...p.tags],['Fly-Raft overflow ‚Üí 2nd last']); k--;
          }
        }
      }
    }
  }

  /* ---- POST-PASS #2: Fill edges first; last boat prefers late sections ---- */
  function trySwapEarlyFromLast(){
    const lastB=boatList[lastIdx]; if(!lastB) return false;
    // find an EARLY pax on last boat
    const earlyIdx = lastB.pax.findIndex(p=>['1st','2nd'].includes(p.row.section));
    if(earlyIdx===-1) return false;
    const earlyP = lastB.pax[earlyIdx];
    // try to find a donor boat with a LATE pax to swap
    for(let j=0;j<boatList.length;j++){
      if(j===lastIdx) continue;
      const src=boatList[j];
      for(let k=0;k<src.pax.length;k++){
        const lateP = src.pax[k];
        if(!['3rd','4th','Unknown'].includes(lateP.row.section)) continue;
        const newLastCount = lastB.count - earlyP.count + lateP.count;
        const newSrcCount  = src.count  - lateP.count  + earlyP.count;
        if(newLastCount<=effSeats(lastB) && newSrcCount<=effSeats(src)){
          // swap
          lastB.pax.splice(earlyIdx,1); lastB.count -= earlyP.count;
          src.pax.splice(k,1);          src.count  -= lateP.count;
          addPax(lastIdx, lateP.row, [...lateP.tags], [...lateP.highlights, 'Late‚ÜíLast swap']);
          addPax(j,       earlyP.row, [...earlyP.tags], [...earlyP.highlights, 'Early‚Üêfrom Last']);
          return true;
        }
      }
    }
    return false;
  }
  // perform multiple swap rounds to improve last boat composition
  let improved=true, guard=0;
  while(improved && guard<50){ improved = trySwapEarlyFromLast(); guard++; }

  /* ---- TW consolidation (after rebalancing) ---- */
  if(twAmb.length) pushMsg(`${twAmb.length} *TW* issue(s).`, 'bad');
  for(const [targetFull, setRows] of twGroups.entries()){
    const members = Array.from(setRows);
    let totalNeed = 0; let maxAssigned = -1;
    members.forEach(r=>{
      const assigned = boatIndexOfRow(r);
      if(assigned > maxAssigned) maxAssigned = assigned;
      if(assigned !== -1){ removeRowFromBoats(r); }
      totalNeed += (r.num||1);
    });
    let anchor = (maxAssigned !== -1) ? maxAssigned : (boatList.length - 1);
    const tryPlaceAt = (idx) => {
      if(idx<0 || idx>=boatList.length) return false;
      const b=boatList[idx];
      if(b.count + totalNeed <= effSeats(b)){ members.forEach(r=>addPax(idx,r,['TW'])); return true; }
      return false;
    };
    let placed = tryPlaceAt(anchor);
    if(!placed){ for(let i=anchor+1;i<boatList.length;i++){ if(tryPlaceAt(i)){ placed=true; break; } } }
    if(!placed){ for(let i=anchor-1;i>=0;i--){ if(tryPlaceAt(i)){ placed=true; break; } } }
    if(!placed){
      pushMsg(`TW group for "${targetFull}" split due to capacity.`, 'bad');
      for(let r of members){
        for(const i of edgeIdx.slice().reverse()){
          const need=r.num||1; const b=boatList[i];
          if(b.count+need<=effSeats(b)){ addPax(i,r,['TW'],['TW group split']); break; }
        }
      }
    }
  }

  /* output */
  const outRows=[["Boat","DepartureOrder","Boat Hold Seats","Boat Tags","Client","No. Pass.","P/U Point","Time","Pickup Notes","Phone","Tags","Highlights","Pickup Section"]];
  resultsEl.innerHTML='';
  let totalPax=0, capacityEff=0;

  boatList.forEach((b,idx)=>{
    totalPax+=b.count; capacityEff+=effSeats(b);
    const boatTags = [
      b.tagDDI?'DDI':'',
      b.tagFly?'Fly-Raft':'',
      b.tagEE?'EE':'',
      b.tagWH?'WH':''
    ].filter(Boolean).join('; ');

    const hdr=document.createElement('div'); hdr.style.margin='10px 0 6px';
    hdr.innerHTML=`<div class="justify">
      <div><b>${idx+1}. ${b.name}</b> &nbsp; <span class="pill ${b.count<=effSeats(b)?'ok':'bad'}">${b.count}/${effSeats(b)}</span></div>
      <div class="chips">
        ${b.tagDDI?'<span class="chip">DDI</span>':''}
        ${b.tagFly?'<span class="chip">Fly-Raft</span>':''}
        ${b.tagEE?'<span class="chip">EE</span>':''}
        ${b.tagWH?'<span class="chip">WH</span>':''}
        ${b.hold?`<span class="chip">Hold: ${b.hold}</span>`:''}
        ${b.toilet?'<span class="chip">üöª</span>':''}
      </div>
    </div>`;
    resultsEl.appendChild(hdr);

    const table=document.createElement('table');
    table.innerHTML=`<thead><tr>
      <th>#</th><th>Client</th><th>No. Pass.</th><th>P/U Point</th><th>Time</th><th>Section</th><th>Tags</th><th>Highlights</th>
    </tr></thead>`;
    const tb=document.createElement('tbody');
    b.pax.forEach((p,i)=>{
      const tags=[...p.tags], hl=[...p.highlights];
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td>${i+1}</td>
        <td>${escapeHtml(p.row.clientRaw)}</td>
        <td>${p.count}</td>
        <td>${escapeHtml(p.row.pu)}</td>
        <td>${p.row.time||''}</td>
        <td>${p.row.section}</td>
        <td>${tags.map(t=>`<span class="pill tag">${t}</span>`).join(' ')}</td>
        <td>${hl.filter(Boolean).map(t=>`<span class="pill warn">${escapeHtml(t)}</span>`).join(' ')}</td>`;
      tb.appendChild(tr);
      outRows.push([b.name,idx+1,b.hold,boatTags,p.row.clientRaw,p.count,p.row.pu,p.row.time||'',p.row.notes||'',p.row.phone||'',tags.join('; '),hl.filter(Boolean).join('; '),p.row.section]);
    });
    table.appendChild(tb); resultsEl.appendChild(table);
  });

  const info=document.createElement('div'); info.className='statusline';
  info.innerHTML = `Total allocated: <b>${totalPax}</b> / Effective capacity: <b>${capacityEff}</b>${totalPax>capacityEff?' <span class="pill bad">Over capacity!</span>':''}`;
  resultsEl.prepend(info);

  const csv=toCSV(outRows), blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}), url=URL.createObjectURL(blob);
  downloadBtn.onclick=()=>{ const tour=tourSelect.value==='south'?'south':'north'; const stamp=new Date().toISOString().slice(0,10);
    const a=document.createElement('a'); a.href=url; a.download=`boat-split-${tour}-${stamp}.csv`; document.body.appendChild(a); a.click(); a.remove(); };
  downloadBtn.disabled=false;
  setStatus('Allocation complete.');
}

/* events */
function wireEvents(){
  resetBtn.addEventListener('click',()=>{ boats=cloneBoats(); renderBoats(); setStatus('Boats reset.'); });
  runBtn.addEventListener('click', allocate);

  fileInput.addEventListener('change', async (e)=>{
    clearMsgs();
    const f=e.target.files?.[0]; if(!f) return;
    const text = await f.text();
    const raw = parseCSV(text);
    if(!raw.length){ setStatus('Empty CSV.'); return; }
    const header = raw[0].map(h=>h.trim());
    const data = raw.slice(1);

    const idxClient=findColIndex(header,COL_ALIASES.client);
    const idxNum   =findColIndex(header,COL_ALIASES.num);
    const idxPU    =findColIndex(header,COL_ALIASES.pu);
    const idxTime  =findColIndex(header,COL_ALIASES.time);
    const idxNotes =findColIndex(header,COL_ALIASES.notes);
    const idxPhone =findColIndex(header,COL_ALIASES.phone);

    if(idxClient<0 || idxPU<0){ setStatus('Missing required columns: need at least Client and P/U Point.'); return; }

    rows = data.map(r=>{
      const clientRaw = norm(r[idxClient]);

      // F+R detection from ANY column
      const numRaw = (r[idxNum]??'').toString();
      const frFromCount  = /\(\s*F\s*\+\s*R\s*\)/i.test(numRaw);
      const frFromClient = /\(\s*F\s*\+\s*R\s*\)/i.test(clientRaw);
      const frFromNotes  = /\(\s*F\s*\+\s*R\s*\)/i.test((idxNotes>=0?String(r[idxNotes]||''):''));
      const flyFromAny   = frFromCount || frFromClient || frFromNotes;

      const numMatch = numRaw.match(/\d+/);
      const num = Math.max(1, numMatch ? parseInt(numMatch[0],10) : 1);

      const pu   = norm(r[idxPU]);
      const time = norm(idxTime>=0?r[idxTime]:'');
      const notes= norm(idxNotes>=0?r[idxNotes]:'');
      const phone= norm(idxPhone>=0?r[idxPhone]:'');
      const timeMins=parseTimeToSortable(time);

      return {
        clientRaw, num, pu, time, timeMins, notes, phone,
        flyFromCount: flyFromAny
      };
    }).filter(r => !/\bweather\s*hold\b/i.test(r.clientRaw)); // drop WEATHER HOLD

    setStatus(`Loaded ${rows.length} rows. Configure boats & holds, then Allocate.`);
    downloadBtn.disabled=true; resultsEl.innerHTML='';
  });
}

/* boot */
function init(){
  try{
    boats = cloneBoats();
    renderBoats();
    wireEvents();
    setStatus('No file loaded. (v=edge-ee7)');
  }catch(e){ console.error(e); window.onerror(e.message,'',0,0,e); }
}
if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
</script>
</body>
</html>
