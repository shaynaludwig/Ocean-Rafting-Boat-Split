<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ocean Rafting — Boat Split</title>
  <style>
    :root{
      --bg:#0b1320; --ink:#f3f6ff; --muted:#9fb0d0; --card:#121a2b; --accent:#7cc4ff; --warn:#ffcf5a; --bad:#ff6b6b; --good:#63e6be;
    }
    html,body{height:100%;}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,sans-serif;background:var(--bg);color:var(--ink);}
    header{display:flex;flex-wrap:wrap;gap:.75rem;align-items:center;justify-content:space-between;padding:1rem 1.25rem;border-bottom:1px solid #1a2540;position:sticky;top:0;background:linear-gradient(180deg,var(--bg) 0%,rgba(11,19,32,.9) 100%);backdrop-filter: blur(6px);z-index:5}
    h1{margin:0;font-size:1.1rem;letter-spacing:.3px;color:var(--ink)}
    .toolbar{display:flex;gap:.5rem;flex-wrap:wrap}
    button,.pill{background:#18223a;border:1px solid #24335a;color:var(--ink);padding:.55rem .8rem;border-radius:.7rem;font-weight:600;cursor:pointer}
    button:hover{background:#1b2745}
    .grid{display:grid;grid-template-columns:repeat(4,minmax(260px,1fr));gap:1rem;padding:1rem;}
    @media (max-width:1200px){.grid{grid-template-columns:repeat(3,1fr)}}
    @media (max-width:900px){.grid{grid-template-columns:repeat(2,1fr)}}
    @media (max-width:640px){.grid{grid-template-columns:1fr}}

    .boat{background:var(--card);border:1px solid #1b2847;border-radius:18px;overflow:hidden;display:flex;flex-direction:column;min-height:280px}
    .boat header{position:relative;background:linear-gradient(180deg,#14203b,#0e172b);border:0;border-bottom:1px solid #24365f;border-radius:18px 18px 0 0;padding:.75rem .9rem}
    .boat h2{font-size:1rem;margin:0}
    .caps{letter-spacing:.08em;text-transform:uppercase;font-size:.72rem;color:var(--muted)}
    .counts{display:flex;gap:.5rem;align-items:center;margin-top:.35rem}
    .cap{padding:.15rem .45rem;border-radius:.5rem;background:#0d1a31;border:1px solid #253a6b;font-size:.75rem}
    .cap.over{background:rgba(255,107,107,.15);border-color:#ff8e8e;color:#ffdede}
    .droprow{display:flex;flex-direction:column;gap:.5rem;padding:.75rem .75rem 1rem;min-height:140px}
    .pax{display:flex;align-items:center;justify-content:space-between;gap:.5rem;padding:.55rem .65rem;background:#0e1931;border:1px solid #22335e;border-radius:.65rem}
    .pax.dragging{opacity:.35}
    .pax .name{font-weight:650}
    .badges{display:flex;gap:.3rem;flex-wrap:wrap}
    .badge{font-size:.7rem;padding:.15rem .4rem;border-radius:.45rem;border:1px solid #2b3e70;background:#0b1429;color:var(--muted)}
    .badge.DDI{border-color:#ffd166;color:#ffd166;background:rgba(255,209,102,.06)}
    .badge.FR{border-color:#7cc4ff;color:#a6d9ff;background:rgba(124,196,255,.07)}
    .badge.MAP{border-color:#63e6be;color:#b2f7e6;background:rgba(99,230,190,.08)}
    .badge.TW{border-color:#ff9cf0;color:#ffd6fa;background:rgba(255,156,240,.08)}
    .help{color:var(--muted);font-size:.9rem;padding:0 1rem 1rem}
    .legend{display:flex;gap:.4rem;align-items:center;flex-wrap:wrap}
    .legend .badge{opacity:.8}
  </style>
</head>
<body>
  <header>
    <h1>Ocean Rafting — Boat Split <span class="caps">(Drag to adjust • MAP rule applied)</span></h1>
    <div class="toolbar">
      <button id="btn-ensure-map">Re‑apply MAP grouping</button>
      <button id="btn-balance">Auto‑balance (keep DDI & MAP fixed)</button>
      <span class="pill">Tip: Drag passengers between boats; totals auto‑update.</span>
    </div>
  </header>

  <div class="help">
    <div class="legend">
      <span class="badge DDI">DDI</span>
      <span class="badge FR">F+R</span>
      <span class="badge MAP">MAP</span>
      <span class="badge TW">TW</span>
      <span>• Never auto‑move DDI. • MAP must be kept together on the <em>last MAP boat</em>. If space runs out there, the system will first move F+R to earlier boats (never DDI).</span>
    </div>
  </div>

  <section class="grid" id="boats"></section>

  <template id="tmpl-boat">
    <article class="boat" data-boat="">
      <header>
        <h2><span class="bname"></span></h2>
        <div class="counts">
          <span class="caps">Capacity:</span>
          <span class="cap"><span class="cur">0</span>/<span class="max">0</span></span>
        </div>
      </header>
      <div class="droprow" data-dropzone></div>
    </article>
  </template>

  <template id="tmpl-pax">
    <div class="pax" draggable="true">
      <span class="name"></span>
      <div class="badges"></div>
    </div>
  </template>

  <script>
  /**********************
   * Config & Data Model *
   **********************/
  const BOATS = [
    { id:"joyride",       name:"Joyride",       cap:32 },
    { id:"thunderstruck", name:"Thunderstruck", cap:32 },
    { id:"blackbetty",    name:"Black Betty",   cap:32 },
    { id:"wipeout",       name:"Wipeout",       cap:32 },
    { id:"riptide",       name:"Riptide",       cap:32 },
    { id:"thrilla",       name:"Thrilla",       cap:25 },
    { id:"jammin",        name:"Jammin",        cap:22 },
    { id:"wildthing",     name:"Wildthing",     cap:19 },
  ];

  // Example allocated passengers (replace with your pipeline results). Name may include markers like "*MAP*" or "F+R" etc.
  // Fields: id, name, tags:Set, twKey: string|null (for TW grouping), section: number (arrival bucket)
  const initialAllocations = {
    joyride: [
      pax("P001","*MAP* Alice Brown", ["MAP"], null, 2),
      pax("P002","F+R Bob Smith", ["FR"], null, 2),
      pax("P003","DDI Carol James", ["DDI"], null, 1),
      pax("P004","TW James & Nina (1)", ["TW"], "TW-JN", 2),
      pax("P005","TW James & Nina (2)", ["TW"], "TW-JN", 2),
    ],
    thunderstruck: [
      pax("P006","*MAP* Charlie Stone", ["MAP"], null, 2),
      pax("P007","Eve Adams", [], null, 2),
      pax("P008","F+R Kora Milne", ["FR"], null, 3),
    ],
    blackbetty: [
      pax("P009","F+R Peter Lang", ["FR"], null, 3),
      pax("P010","Normal Pax", [], null, 3),
    ],
    wipeout: [
      pax("P011","DDI Sam Day", ["DDI"], null, 1),
      pax("P012","*MAP* Zara Lee", ["MAP"], null, 2),
    ],
    riptide: [],
    thrilla: [],
    jammin: [],
    wildthing: [
      pax("P013","F+R Quinn Roe", ["FR"], null, 3),
    ],
  };

  function pax(id, name, tagsArr=[], twKey=null, section=2){
    const tags = new Set(tagsArr);
    // Infer tags from name if present
    const upper = name.toUpperCase();
    if(/\*?MAP\*?/i.test(name)) tags.add("MAP");
    if(/\bF\s*\+\s*R\b/i.test(name)) tags.add("FR");
    if(/\bDDI\b/i.test(name)) tags.add("DDI");
    if(/\bTW\b|\*TW\*/i.test(name)) tags.add("TW");
    return { id, name, tags, twKey, section };
  }

  /**********************
   * DOM Construction    *
   **********************/
  const elGrid = document.getElementById('boats');
  const boatEls = new Map(); // id -> {root, dropzone, capEl}

  function buildBoats(){
    elGrid.innerHTML = '';
    const boatTpl = document.getElementById('tmpl-boat');
    BOATS.forEach(b=>{
      const node = boatTpl.content.cloneNode(true);
      const root = node.querySelector('.boat');
      const dropzone = node.querySelector('[data-dropzone]');
      root.dataset.boat = b.id;
      root.querySelector('.bname').textContent = b.name;
      root.querySelector('.max').textContent = String(b.cap);
      addDropzoneDnD(dropzone);
      elGrid.appendChild(node);
      boatEls.set(b.id, { root: elGrid.lastElementChild, dropzone: elGrid.lastElementChild.querySelector('[data-dropzone]'), capEl: elGrid.lastElementChild.querySelector('.cap'), max:b.cap });
    });
  }

  function renderAllocations(alloc){
    for(const [bid, arr] of Object.entries(alloc)){
      const b = boatEls.get(bid); if(!b) continue;
      b.dropzone.innerHTML = '';
      arr.forEach(p=> b.dropzone.appendChild(renderPax(p)) );
      updateCount(bid);
    }
  }

  function renderPax(p){
    const tpl = document.getElementById('tmpl-pax');
    const node = tpl.content.cloneNode(true);
    const el = node.querySelector('.pax');
    el.dataset.pid = p.id;
    el.dataset.tags = JSON.stringify([...p.tags]);
    el.dataset.tw = p.twKey || '';
    el.dataset.section = p.section;
    el.querySelector('.name').textContent = p.name;
    const badges = el.querySelector('.badges');
    p.tags.forEach(t=>{
      const sp = document.createElement('span');
      sp.className = `badge ${t}`;
      sp.textContent = t;
      badges.appendChild(sp);
    });
    addCardDnD(el);
    return el;
  }

  /**********************
   * Drag & Drop         *
   **********************/
  let dragging = null;
  function addCardDnD(card){
    card.addEventListener('dragstart', (e)=>{
      dragging = card; card.classList.add('dragging');
      e.dataTransfer.effectAllowed = 'move';
    });
    card.addEventListener('dragend', ()=>{
      card.classList.remove('dragging');
      dragging = null; refreshAllCounts();
    });
  }
  function addDropzoneDnD(zone){
    zone.addEventListener('dragover', (e)=>{
      e.preventDefault();
      const after = getDragAfterElement(zone, e.clientY);
      if(!dragging) return;
      if(after==null) zone.appendChild(dragging); else zone.insertBefore(dragging, after);
    });
    zone.addEventListener('drop', ()=>{ refreshAllCounts(); });
  }
  function getDragAfterElement(container, y){
    const els = [...container.querySelectorAll('.pax:not(.dragging)')];
    return els.reduce((closest, child)=>{
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height/2;
      if(offset < 0 && offset > closest.offset){ return { offset, element: child }; }
      else return closest;
    }, {offset: Number.NEGATIVE_INFINITY}).element;
  }

  /**********************
   * Helpers             *
   **********************/
  function readState(){
    const state = {};
    for(const {root, dropzone} of boatEls.values()){
      const id = root.dataset.boat; state[id] = [];
      dropzone.querySelectorAll('.pax').forEach(el=>{
        state[id].push({
          id: el.dataset.pid,
          name: el.querySelector('.name').textContent,
          tags: new Set(JSON.parse(el.dataset.tags||'[]')),
          twKey: el.dataset.tw || null,
          section: Number(el.dataset.section||2)
        });
      });
    }
    return state;
  }

  function refreshAllCounts(){ BOATS.forEach(b=> updateCount(b.id)); }

  function updateCount(boatId){
    const b = boatEls.get(boatId); if(!b) return; 
    const cur = b.dropzone.querySelectorAll('.pax').length;
    const max = b.max;
    b.capEl.querySelector('.cur').textContent = String(cur);
    b.capEl.classList.toggle('over', cur>max);
  }

  function boatOrderIndex(boatId){ return BOATS.findIndex(b=>b.id===boatId); }

  /**********************
   * MAP Grouping Logic  *
   **********************/
  function ensureMAPTogether(){
    const state = readState();
    // 1) Gather all MAP pax and where they are
    const mapEntries = [];
    for(const [bid, paxArr] of Object.entries(state)){
      paxArr.forEach(p=>{ if(p.tags.has('MAP')) mapEntries.push({boatId:bid, pax:p}); });
    }
    if(mapEntries.length===0){ refreshAllCounts(); return; }

    // 2) Choose the "last MAP boat": the MAP-carrying boat with the highest order index, else the last boat overall
    let lastMapBoat = null;
    const withMap = [...new Set(mapEntries.map(x=>x.boatId))];
    if(withMap.length>0){
      lastMapBoat = withMap.sort((a,b)=> boatOrderIndex(b)-boatOrderIndex(a))[0];
    } else {
      lastMapBoat = BOATS[BOATS.length-1].id;
    }

    // 3) Move all MAP pax into lastMapBoat, making room by evicting first FR then others (never DDI)
    const target = boatEls.get(lastMapBoat);
    if(!target) return;

    // Collect MAP pax nodes and append to target
    const needed = mapEntries.map(x=> document.querySelector(`.pax[data-pid="${x.pax.id}"]`) ).filter(Boolean);
    needed.forEach(node=> target.dropzone.appendChild(node));

    // 4) If over capacity, push out candidates (prefer FR) to earlier boats with space; never DDI; never evict MAP
    function currentCount(){ return target.dropzone.querySelectorAll('.pax').length; }
    const maxCap = target.max;

    const candidates = [...target.dropzone.querySelectorAll('.pax')]
      .map(el=>({el, tags:new Set(JSON.parse(el.dataset.tags||'[]'))}))
      .filter(x=> !x.tags.has('MAP') && !x.tags.has('DDI'));

    const FRfirst = candidates.filter(x=> x.tags.has('FR'));
    const others = candidates.filter(x=> !x.tags.has('FR'));

    const toEvict = [...FRfirst, ...others];

    for(const cand of toEvict){
      if(currentCount()<=maxCap) break;
      const placed = moveToEarlierBoat(cand.el);
      if(!placed){
        // If cannot place earlier, try any other boat with space (still avoiding later than target to keep MAP as last group)
        const anyPlaced = moveToAnyBoatWithSpace(cand.el, /*preferEarlier=*/true);
        if(!anyPlaced){ break; }
      }
    }

    refreshAllCounts();
  }

  function moveToEarlierBoat(card){
    // Try earlier boats by order index that have free capacity and allow tag constraints
    const fromBoat = card.closest('.boat').dataset.boat;
    const fromIdx = boatOrderIndex(fromBoat);
    for(let i=0; i<fromIdx; i++){
      const bid = BOATS[i].id; const b = boatEls.get(bid);
      if(!b) continue;
      if(b.dropzone.querySelectorAll('.pax').length < b.max){
        // Respect DDI immovable rule only for FROM, not necessary here as we filtered them out
        b.dropzone.appendChild(card); return true;
      }
    }
    return false;
  }
  function moveToAnyBoatWithSpace(card, preferEarlier=false){
    const fromBoat = card.closest('.boat').dataset.boat;
    const order = [...BOATS];
    if(preferEarlier){ order.sort((a,b)=> boatOrderIndex(a.id)-boatOrderIndex(b.id)); }
    for(const binfo of order){
      if(binfo.id===fromBoat) continue;
      const b = boatEls.get(binfo.id);
      if(!b) continue;
      if(b.dropzone.querySelectorAll('.pax').length < b.max){ b.dropzone.appendChild(card); return true; }
    }
    return false;
  }

  /**********************
   * Auto‑balance (optional)
   **********************/
  function autoBalance(){
    // Keeps DDI and MAP fixed; shift FR and normal earlier to relieve overflows
    const state = readState();
    // Pass 1: If any boat over cap, move out FR then others to earlier boats
    for(const binfo of BOATS){
      const b = boatEls.get(binfo.id); if(!b) continue;
      while(b.dropzone.querySelectorAll('.pax').length > b.max){
        const rows = [...b.dropzone.querySelectorAll('.pax')].map(el=>({el, tags:new Set(JSON.parse(el.dataset.tags||'[]'))}));
        const movable = rows.filter(r=> !r.tags.has('DDI') && !r.tags.has('MAP'));
        const FRfirst = movable.filter(r=> r.tags.has('FR'));
        const others = movable.filter(r=> !r.tags.has('FR'));
        const cand = (FRfirst[0] || others[0]);
        if(!cand) break; // can't move further, give up
        if(!moveToEarlierBoat(cand.el)){
          if(!moveToAnyBoatWithSpace(cand.el, true)) break;
        }
      }
    }
    refreshAllCounts();
  }

  /**********************
   * Boot                *
   **********************/
  function boot(){
    buildBoats();
    renderAllocations(initialAllocations);
    ensureMAPTogether();
    document.getElementById('btn-ensure-map').addEventListener('click', ensureMAPTogether);
    document.getElementById('btn-balance').addEventListener('click', autoBalance);
  }
  document.addEventListener('DOMContentLoaded', boot);
  </script>
</body>
</html>
