<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ocean Rafting â€” Boat Split</title>

<!-- Cache buster -->
<script>
  const APP_VERSION = '2025-09-17-holding-boat-reliableversion';
  (function(){
    try{
      const u = new URL(location.href);
      if (u.searchParams.get('v') !== APP_VERSION) {
        u.searchParams.set('v', APP_VERSION);
        history.replaceState(null,'',u);
      }
    }catch{}
  })();
</script>

<style>
  :root{
    --bg:#ffffff; --ink:#111827; --muted:#6b7280; --line:#e5e7eb; --panel:#ffffff;
    --brand:#2563eb; --brand-600:#1d4ed8; --shadow:0 6px 18px rgba(0,0,0,.06);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);
       font:15px/1.55 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
       scrollbar-gutter:stable both-edges;}
  header{padding:18px 20px;border-bottom:1px solid var(--line);background:#fff}
  header h1{margin:0;font-size:22px;font-weight:800;letter-spacing:.2px}
  header p{margin:2px 0 0;color:var(--muted);font-size:13px}
  .container{max-width:1120px;margin:0 auto;padding:20px 16px 32px;}
  .section{background:var(--panel);border:1px solid var(--line);border-radius:12px;
           padding:16px;box-shadow:var(--shadow);margin-bottom:16px;}
  .section-title{margin:0 0 12px;font-weight:800;letter-spacing:.2px;font-size:13px;color:#374151;text-transform:uppercase;}
  label{display:block;margin:8px 0 6px;color:#374151}
  input[type="file"],select,input[type="number"],input[type="text"]{
    width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--line);
    background:#fff;color:#111827;outline:none
  }
  input[type="file"]{padding:8px 10px}
  .muted{color:var(--muted)}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,monospace;font-size:12px}
  .toolbar{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .btn{display:inline-flex;align-items:center;gap:8px;padding:10px 14px;border-radius:10px;
       border:1px solid var(--line);background:#fff;color:#111827;cursor:pointer;text-decoration:none}
  .btn:hover{background:#f3f4f6}
  .btn-primary{background:var(--brand);border-color:var(--brand);color:#fff}
  .btn-primary:hover{background:#1d4ed8}
  .btn-danger{background:#fff;border-color:#fca5a5;color:#b91c1c}
  .btn-danger:hover{background:#fee2e2}
  .btn[disabled]{opacity:.55;cursor:not-allowed}
  .boats{display:grid;gap:10px;grid-template-columns:1fr}
  @media(min-width:680px){.boats{grid-template-columns:1fr 1fr}}
  @media(min-width:980px){.boats{grid-template-columns:1fr 1fr 1fr}}
  .boat{border:1px solid var(--line);border-radius:12px;padding:12px;box-shadow:var(--shadow)}
  .just{display:flex;justify-content:space-between;align-items:center;gap:8px}
  .boat h4{margin:0 0 6px;font-size:15px}
  .controls-inline{display:flex;gap:6px}
  .row{display:flex;gap:10px;flex-wrap:wrap}
  .row>*{flex:1 1 120px}
  .row-tight{gap:6px}
  .tagline label{display:flex;align-items:center;gap:6px;margin:0}
  .chips{display:flex;flex-wrap:wrap;gap:6px}
  .chip{background:#eef2ff;border:1px solid #c7d2fe;color:#1f2937;
        padding:5px 8px;border-radius:999px;font-size:12px;white-space:nowrap}
  .pill{display:inline-block;padding:4px 9px;border-radius:999px;border:1px solid var(--line);font-size:12px}
  .ok{background:#ecfdf5;border-color:#bbf7d0;color:#065f46}
  .warn{background:#fffbeb;border-color:#fde68a;color:#92400e}
  .bad{background:#fef2f2;border-color:#fecaca;color:#991b1b}
  .tag{background:#eff6ff;border-color:#bfdbfe;color:#1e3a8a}
  table{width:100%;border-collapse:separate;border-spacing:0}
  thead th{background:#f3f4f6;color:#111827;text-align:left;font-weight:800;border-bottom:1px solid var(--line);padding:10px 8px}
  tbody td{border-bottom:1px solid var(--line);padding:10px 8px}
  tbody tr:nth-child(2n){background:#fafafa}
  tbody tr:hover{background:#f5f5f5}
  tbody tr[data-rowid]{cursor:move}
  .droptarget{outline:2px dashed #93c5fd; outline-offset:4px; border-radius:8px}
  .err{white-space:pre-wrap;background:#fff1f2;color:#881337;border:1px solid #fecdd3;border-radius:10px;padding:10px;margin:12px 0}
</style>
</head>
<body>
<header>
  <h1>Boat Split</h1>
  <p>Upload CSV â†’ tag boats (DDI / Fly / EE) â†’ Allocate â†’ Drag & drop final tweaks â†’ Download CSV</p>
</header>

<main class="container" id="app">
  <div class="section">
    <div class="section-title">Upload file</div>
    <input type="file" id="file" accept=".csv" />
    <div class="muted" style="margin-top:6px">
      Columns expected (flexible names): <span class="mono chip">Client</span> <span class="mono chip">No. Pass.</span>
      <span class="mono chip">P/U Point</span> <span class="mono chip">Time</span> <span class="mono chip">Pickup Notes</span>
    </div>
  </div>

  <div class="section">
    <div class="section-title">Tour & actions</div>
    <div class="row">
      <label style="max-width:280px">Tour
        <select id="tour"><option value="north">Northern</option><option value="south">Southern</option></select>
      </label>
    </div>
    <div class="toolbar">
      <button id="resetBoats" class="btn">Reset boats</button>
      <button id="run" class="btn btn-primary">Allocate</button>
      <button id="download" class="btn" disabled>Download CSV</button>
    </div>
    <div id="status" class="muted" style="margin-top:10px">Bootingâ€¦</div>
    <div id="messages" class="chips" style="margin-top:10px"></div>
  </div>

  <div class="section">
    <div class="section-title">Boats in order (earliest â†’ latest)</div>
    <div class="muted" style="margin-bottom:8px">
      Reorder (â–²/â–¼), set tags (DDI / Fly-Raft / EE), hold seats, or remove with Ã—. DDI & Fly are mutually exclusive.
    </div>
    <div id="boats" class="boats"></div>
  </div>

  <div class="section">
    <div class="section-title">Results</div>
    <div id="results" class="muted">Upload a CSV and click <b>Allocate</b>.</div>
  </div>
</main>

<script>
"use strict";

/* ========= Error banner ========= */
window.onerror = (msg, src, line, col, err) => {
  const host = document.querySelector('#results');
  const pre = document.createElement('div');
  pre.className = 'err';
  pre.textContent = `Script error:\n${msg}\n${src?('at '+src+':'+line+':'+col):''}\n` + (err&&err.stack?err.stack:'');
  host?.prepend(pre);
};

/* ========= Helpers ========= */
const el = id => document.getElementById(id);
const setStatus = s => { const n=el('status'); if(n) n.textContent = s; };
const messagesEl = document.getElementById('messages');
function clearMsgs(){ if(messagesEl) messagesEl.innerHTML=''; }
function pushMsg(text,tone=''){
  if(!messagesEl) return;
  const m=document.createElement('span'); m.className='chip';
  const col = tone==='ok'?'#16a34a':tone==='warn'?'#f59e0b':tone==='bad'?'#ef4444':'#c7d2fe';
  m.style.borderColor=col; m.textContent=text; messagesEl.appendChild(m);
}
const norm = s => (s??'').toString().trim();
const lower = s => norm(s).toLowerCase();
const escapeHtml = s => (s??'').replace(/[&<>"']/g,m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m]));
const rowIsBlank = row => !row || !row.length || row.every(c => norm(c)==='');

/* ========= Defaults ========= */
const DEFAULT_BOATS = [
  { name: "Joyride",        seats: 32, toilet: true },
  { name: "Thunderstruck",  seats: 32, toilet: true },
  { name: "Black Betty",    seats: 32, toilet: true },
  { name: "Wipeout",        seats: 32, toilet: true },
  { name: "Riptide",        seats: 32, toilet: true },
  { name: "Thrilla",        seats: 25, toilet: false },
  { name: "Jammin",         seats: 22, toilet: true },
  { name: "Wildthing",      seats: 19, toilet: false },
];
let boats = [];
let rows = [];
let popups = [];
let runtime = null; // {B, eff, N, holding, unallocated}

/* ========= CSV parsing ========= */
function parseCSV(text){
  const rows=[]; let cur='',row=[],inQ=false; let i=0;
  while(i<text.length){ const ch=text[i];
    if(inQ){ if(ch==='"'){ if(text[i+1]==='"'){cur+='"';i+=2;continue} inQ=false;i++;continue } cur+=ch; i++; continue; }
    if(ch==='"'){ inQ=true; i++; continue; }
    if(ch===','){ row.push(cur); cur=''; i++; continue; }
    if(ch==='\r'){ i++; continue; }
    if(ch==='\n'){ row.push(cur); rows.push(row); row=[]; cur=''; i++; continue; }
    cur+=ch; i++;
  }
  row.push(cur); rows.push(row);
  return rows;
}
const COL_ALIASES = {
  client:["client","name","full name","passenger","pax name"],
  num:["no. pass.","no pass","passengers","pax","qty","count","no.pass","no pass.","no of pax"],
  pu:["p/u point","pickup point","p/u","pick up","pickup","location","p/u address","pickup address","pu point","accommodation","accom"],
  time:["time","pickup time","p/u time","pu time"],
  notes:["pickup notes","notes","comments","pu comments","p/u notes","pu notes","comment"],
  phone:["phone","mobile","contact","contact phone"]
};
function findColIndex(h,keys){
  const lowerh=h.map(x=>x.toLowerCase());
  for(const k of keys){ const i=lowerh.indexOf(k); if(i!==-1) return i; }
  for(let i=0;i<lowerh.length;i++){ if(keys.some(k=>lowerh[i].includes(k))) return i; }
  return -1;
}
function parseTimeToSortable(t){
  if(!t) return null; let s=t.toString().trim(); if(!s) return null;
  s=s.replace('.',':'); const ampm=/am|pm/i.test(s)?s.match(/am|pm/i)[0].toLowerCase():null;
  s=s.replace(/[^0-9:]/g,''); if(/^\d{3,4}$/.test(s)){ s=(s.length===3?'0'+s:s); s=s.slice(0,2)+':'+s.slice(2); }
  if(!/^\d{1,2}:\d{2}$/.test(s)) return null;
  let [hh,mm]=s.split(':').map(n=>parseInt(n,10)); if(ampm){ if(ampm==='pm'&&hh<12)hh+=12; if(ampm==='am'&&hh===12)hh=0; }
  if(hh>=0&&hh<24&&mm>=0&&mm<60) return hh*60+mm; return null;
}
function quartileSection(mins, sortedDistinct){
  if(mins==null) return 'Unknown'; const n=sortedDistinct.length; if(!n) return 'Unknown';
  const q1=sortedDistinct[Math.floor(n*.25)], q2=sortedDistinct[Math.floor(n*.50)], q3=sortedDistinct[Math.floor(n*.75)];
  if(mins<=q1) return '1st'; if(mins<=q2) return '2nd'; if(mins<=q3) return '3rd'; return '4th';
}

/* ========= Boat colors ========= */
function boatStyleForName(name){
  const n=(name||'').toLowerCase();
  if(n.includes('joyride'))       return { bg:'#ddd6fe', fg:'#1f2937', br:'#c4b5fd' };
  if(n.includes('black betty'))   return { bg:'#111827', fg:'#ffffff', br:'#0b0f1a' };
  if(n.includes('thunderstruck')) return { bg:'#fecaca', fg:'#1f2937', br:'#fca5a5' };
  if(n.includes('wipeout'))       return { bg:'#ffffff', fg:'#111827', br:'#e5e7eb' };
  if(n.includes('thrilla'))       return { bg:'#fef3c7', fg:'#1f2937', br:'#fde68a' };
  if(n.includes('jammin'))        return { bg:'#dcfce7', fg:'#1f2937', br:'#bbf7d0' };
  if(n.includes('wildthing'))     return { bg:'#dbeafe', fg:'#1f2937', br:'#bfdbfe' };
  if(n.includes('riptide'))       return { bg:'#f1f5f9', fg:'#1f2937', br:'#e2e8f0' };
  return { bg:'#ffffff', fg:'#111827', br:'#e5e7eb' };
}

/* ========= Boats UI ========= */
function cloneBoats(){ return DEFAULT_BOATS.map(b=>({...b, tagDDI:false, tagFly:false, tagEE:false, hold:0 })); }

function renderBoats(){
  const wrap = document.getElementById('boats');
  if (!wrap) { setStatus('Boats container missing.'); return; }
  try{
    wrap.innerHTML='';
    if(!boats || !Array.isArray(boats)) boats = [];
    if(!boats.length) boats = cloneBoats();

    boats.forEach((b,idx)=>{
      const style = boatStyleForName(b.name);
      const box=document.createElement('div'); box.className='boat';
      box.style.background = style.bg;
      box.style.color = style.fg;
      box.style.borderColor = style.br;

      box.innerHTML=`
        <div class="just">
          <div>
            <h4 style="color:${style.fg}">${idx+1}. ${b.name} ${b.toilet?'ðŸš»':''}</h4>
            <div style="font-size:12px; color:${style.fg}">${b.seats} seats${b.toilet?', toilet':''}</div>
          </div>
          <div class="controls-inline">
            <button class="btn" data-act="up" data-idx="${idx}" title="Earlier">â–²</button>
            <button class="btn" data-act="down" data-idx="${idx}" title="Later">â–¼</button>
            <button class="btn btn-danger" data-act="remove" data-idx="${idx}" title="Remove boat">Ã—</button>
          </div>
        </div>
        <div class="row row-tight" style="margin-top:8px; align-items:center">
          <div class="tagline" style="display:flex; gap:10px; flex-wrap:wrap">
            <label><input type="checkbox" data-act="ddi" data-idx="${idx}" ${b.tagDDI?'checked':''}/> DDI</label>
            <label><input type="checkbox" data-act="fly" data-idx="${idx}" ${b.tagFly?'checked':''}/> Fly-Raft</label>
            <label><input type="checkbox" data-act="ee"  data-idx="${idx}" ${b.tagEE?'checked':''}/> EE</label>
          </div>
          <div style="flex:1"></div>
          <label style="margin:0; flex:0 0 160px">Hold seats
            <input type="number" data-act="hold" data-idx="${idx}" min="0" max="${b.seats}" value="${b.hold||0}" />
          </label>
        </div>
      `;
      wrap.appendChild(box);
    });

    wrap.querySelectorAll('button').forEach(btn=>{
      btn.onclick=()=>{
        const idx=+btn.dataset.idx, act=btn.dataset.act;
        if(act==='up'&&idx>0){ [boats[idx-1],boats[idx]]=[boats[idx],boats[idx-1]]; renderBoats(); }
        if(act==='down'&&idx<boats.length-1){ [boats[idx+1],boats[idx]]=[boats[idx],boats[idx+1]]; renderBoats(); }
        if(act==='remove'){ boats.splice(idx,1); renderBoats(); setStatus('Boat removed.'); }
      };
    });
    wrap.querySelectorAll('input').forEach(inp=>{
      inp.onchange=()=>{
        const idx=+inp.dataset.idx, act=inp.dataset.act;
        if(act==='ddi'){ boats[idx].tagDDI=inp.checked; if(inp.checked) boats[idx].tagFly=false; }
        if(act==='fly'){ boats[idx].tagFly=inp.checked; if(inp.checked) boats[idx].tagDDI=false; }
        if(act==='ee'){ boats[idx].tagEE=inp.checked; }
        if(act==='hold'){
          let v=parseInt(inp.value||'0',10); v=isNaN(v)?0:v;
          v=Math.max(0,Math.min(v,boats[idx].seats)); boats[idx].hold=v; inp.value=String(v);
        }
        renderBoats();
      };
    });
  }catch(e){
    const errBox=document.createElement('div');
    errBox.className='err';
    errBox.textContent='Boats render error: '+ (e && e.stack ? e.stack : String(e));
    wrap.parentElement.prepend(errBox);
  }
}

/* ========= Core allocation small ops ========= */
function addEntry(B, i, e){ B[i].pax.push(e); B[i].count += e.count; }
function removeEntry(B, i, e){
  const k = B[i].pax.indexOf(e);
  if(k>=0){ B[i].pax.splice(k,1); B[i].count -= e.count; return true; }
  return false;
}

/* ========= Allocation ========= */
function allocate(){
  clearMsgs(); popups = [];
  if(!rows.length){ setStatus('Please upload a CSV first.'); return; }
  if(!boats.length){ setStatus('No boats in use. Click "Reset boats".'); return; }

  // Working copy of boats
  const B = boats.map(b=>({
    name:b.name,seats:b.seats,toilet:b.toilet,
    tagDDI:!!b.tagDDI, tagFly:!!b.tagFly, tagEE:!!b.tagEE,
    hold: Math.max(0,Math.min(b.hold||0,b.seats)),
    pax:[], count:0
  }));
  const N = B.length;
  const eff = b => Math.max(0, b.seats - b.hold); // effective capacity (user holds only)

  // ===== Hidden holding "boat" (not rendered) =====
  const HOLD = { name:'__HOLDING__', pax:[], count:0 };

  // Sections
  const distinct=[...new Set(rows.map(r=>r.timeMins).filter(v=>v!=null))].sort((a,b)=>a-b);
  rows.forEach(r=>r.section = quartileSection(r.timeMins, distinct));
  const secOrder = s => ({'1st':0,'2nd':1,'3rd':2,'4th':3,'Unknown':4}[s] ?? 4);

  // Classifiers
  const isDDI = r => /daydream\s*island/i.test(r.pu);
  const isEE  = r => /\bee\b/i.test(r.notes||'');
  const noteFly = r => /(fly[-\s]*raft|fly\s*raft)/i.test(r.notes||'');
  const hasFR = r => /\(\s*F\s*\+\s*R\s*\)/i.test(r.clientRaw)||r.flyFromCount||noteFly(r);
  const wantsEarly = r => /early\s*boat/i.test(r.notes||'');
  const isOwnWayOrUnknown = r =>
    /(own\s*way|tba|tbc|not\s*[-\s]*sure|unsure|unknown)/i.test(r.pu||'') ||
    /(own\s*way|tba|tbc|not\s*[-\s]*sure|unsure|unknown)/i.test(r.notes||'') ||
    r.section==='Unknown';
  const isMAP = r => /\*map\*/i.test(r.clientRaw);

  // Filter & decorate
  const charter = r => /charter/i.test(r.pu);
  const wHoldName = r => /\bweather\s*hold\b/i.test(r.clientRaw);
  const prepared = rows.slice();
  const ignoredCharter = prepared.filter(r=>charter(r));
  const filtered = prepared.filter(r=>!wHoldName(r) && !charter(r));
  filtered.forEach((r)=>{
    r.isDDI=isDDI(r);
    r.isFR =hasFR(r);
    r.isEE =isEE(r);
    r.wantsEarly=wantsEarly(r);
    r.isOwnWayOrUnknown=isOwnWayOrUnknown(r);
    r.isMAP=isMAP(r);
  });

  const totalNeed = filtered.reduce((s,r)=>s+(r.num||1),0);
  const totalEffCap = B.reduce((s,b)=>s+eff(b),0);

  // Section target â†’ boat index
  function sectionTargetIndex(section, n){
    if(section==='1st') return 0;
    if(section==='2nd') return Math.round((n-1)/3);
    if(section==='3rd') return Math.round(2*(n-1)/3);
    if(section==='4th') return n-1;
    return n-1; // Unknown â†’ latest
  }
  function neighbors(idx, refRow){
    const t = sectionTargetIndex(refRow.section, N);
    const opts=[]; if(idx-1>=0) opts.push(idx-1); if(idx+1<N) opts.push(idx+1);
    return opts.sort((a,b)=>Math.abs(a-t)-Math.abs(b-t)||a-b);
  }
  function sectionDistance(row,boatIdx){ const t=sectionTargetIndex(row.section,N); return Math.abs(boatIdx - t); }

  // Entry model
  function entryFromRows(rowsArr, locked=false, tags=[]){
    return {
      id: Math.random().toString(36).slice(2),
      members: rowsArr.slice(),
      count: rowsArr.reduce((s,x)=>s+(x.num||1),0),
      locked,
      tags:new Set(tags),
      highlights:new Set()
    };
  }
  function flags(e){
    const any=f=>e.members.some(x=>x[f]);
    const sec=e.members.map(x=>x.section).sort((a,b)=>secOrder(a)-secOrder(b))[0]||'Unknown';
    return {
      section: sec,
      isDDI: any('isDDI'),
      isFR:  any('isFR'),
      preferEE: any('isEE') && sec!=='1st',
      wantsEarly: any('wantsEarly'),
      isOwnWayOrUnknown: any('isOwnWayOrUnknown'),
      isMAP: any('isMAP'),
      rep: e.members[0]
    };
  }
  function canSeatOnBoat(e,i){
    const b=B[i]; const f=flags(e);
    if(f.isFR && !b.tagFly) return false;                   // FR strictly Fly
    if(f.isDDI) return b.tagDDI===true;                     // DDI strictly DDI
    if(b.tagDDI && (f.section==='3rd'||f.section==='4th'||f.section==='Unknown')) return false; // no late/unknown on DDI by default
    return true;
  }

  /* ===== Single-assignment & hard-cap guards ===== */
  filtered.forEach(r=>{ if(!r._id) r._id = Math.random().toString(36).slice(2); });
  const assignedTo = new Map(); // rowId -> boatIdx (not used for HOLD)
  function safeAddEntry(boatIdx, e){
    const fresh = e.members.filter(m => !assignedTo.has(m._id));
    if(!fresh.length) return false;
    const addCount = fresh.reduce((s,x)=>s+(x.num||1),0);
    if (B[boatIdx].count + addCount > eff(B[boatIdx])) return false; // never overfill
    e.members = fresh; e.count = addCount;
    addEntry(B, boatIdx, e);
    for(const m of fresh) assignedTo.set(m._id, boatIdx);
    return true;
  }
  function safeMoveWholeEntry(fromIdx, toIdx, e){
    if (B[toIdx].count + e.count > eff(B[toIdx])) return false;
    removeEntry(B, fromIdx, e);
    addEntry(B, toIdx, e);
    for(const m of e.members) assignedTo.set(m._id, toIdx);
    return true;
  }

  /* ===== Holding helpers ===== */
  function moveToHold(fromIdx, e, reason){
    removeEntry(B, fromIdx, e);
    HOLD.pax.push(e); HOLD.count += e.count;
    e.highlights.add(reason || 'Holding swap');
  }
  function tryDrainHoldOnce(){ // one pass
    let moved=false;
    for(let k=HOLD.pax.length-1;k>=0;k--){
      const e=HOLD.pax[k];
      if(placeUnit(e, /*allowHolding*/ false)){ // place without using holding again
        HOLD.pax.splice(k,1); HOLD.count -= e.count;
        moved=true;
      }
    }
    return moved;
  }

  // Free room on a target boat by moving some entries to holding
  function freeWithHolding(boatIdx, need){
    const effCap = eff(B[boatIdx]);
    let freeNow = effCap - B[boatIdx].count;
    if (freeNow >= need) return true;

    const movable=B[boatIdx].pax.filter(x=>!x.locked);
    // Prefer entries furthest from their section target, and larger first
    movable.sort((a,b)=>{
      const da=sectionDistance(flags(a).rep, boatIdx), db=sectionDistance(flags(b).rep, boatIdx);
      if(da!==db) return db-da;
      return b.count - a.count;
    });

    for (const e of movable){
      moveToHold(boatIdx, e, 'Holding swap to free capacity');
      freeNow += e.count;
      if (freeNow >= need) return true;
    }
    return false;
  }

  /* ===== Ripple (now can fall back to holding) ===== */
  function tryMoveEntry(fromIdx, e, depth, seen){
    const rep = flags(e).rep;
    for(const nb of neighbors(fromIdx, rep)){
      if(!canSeatOnBoat(e,nb)) continue;
      // direct
      if(B[nb].count + e.count <= eff(B[nb])){
        removeEntry(B, fromIdx, e); addEntry(B, nb, e); e.highlights.add('Ripple move'); return true;
      }
      // neighbor ripple
      if(depth>0){
        const key = nb+'|'+e.id;
        if(!seen.has(key)){
          seen.add(key);
          if(rippleFree(nb, e.count, rep, depth-1, seen)){
            removeEntry(B, fromIdx, e); addEntry(B, nb, e); e.highlights.add('Ripple move'); return true;
          }
        }
      }
      // holding swap on neighbor if still stuck
      const deficit = e.count - (eff(B[nb]) - B[nb].count);
      if (deficit > 0 && freeWithHolding(nb, deficit)){
        removeEntry(B, fromIdx, e); addEntry(B, nb, e); e.highlights.add('Ripple via holding'); return true;
      }
    }
    return false;
  }
  function rippleFree(boatIdx, need, orientRow, depth, seen){
    const effCap = eff(B[boatIdx]);
    if(effCap - B[boatIdx].count >= need) return true;
    const movable=B[boatIdx].pax.filter(x=>!x.locked);
    movable.sort((a,b)=>{
      const da=sectionDistance(flags(a).rep, boatIdx), db=sectionDistance(flags(b).rep, boatIdx);
      if(da!==db) return db-da; return b.count - a.count;
    });
    for(const e of movable){
      if(tryMoveEntry(boatIdx,e,depth,seen)){
        if(effCap - B[boatIdx].count >= need) return true;
      }
    }
    // As a last resort on this boat, push to holding
    const deficit = need - (eff(B[boatIdx]) - B[boatIdx].count);
    if(deficit>0 && freeWithHolding(boatIdx, deficit)){
      return true;
    }
    return false;
  }

  /* ====== DDI strict ====== */
  let ddiIdx = [...Array(N).keys()].filter(i=>B[i].tagDDI);
  const ddiRows = filtered.filter(r=>r.isDDI);
  if(ddiRows.length && !ddiIdx.length && N){ B[0].tagDDI=true; ddiIdx=[0]; pushMsg('Auto-tagged earliest boat as DDI.','warn'); }
  for(const r of ddiRows){
    const e = entryFromRows([r], true, ['DDI']);
    let placed=false;
    for(const i of ddiIdx){
      if(B[i].count + e.count <= eff(B[i])){ placed=safeAddEntry(i,e); if(placed) break; }
    }
    if(!placed){
      for(const i of ddiIdx){
        const seen=new Set();
        if(rippleFree(i, e.count, r, 3, seen)){ placed=safeAddEntry(i,e); if(placed){ e.highlights.add('Ripple move'); break; } }
        if(!placed){
          const deficit = e.count - (eff(B[i]) - B[i].count);
          if(deficit>0 && freeWithHolding(i, deficit)){
            placed=safeAddEntry(i,e); if(placed){ e.highlights.add('Placed via holding'); break; }
          }
        }
      }
    }
    if(!placed){
      pushMsg('DDI overflow: moved DDI pax into holding; will attempt later.','warn');
      moveToHold(ddiIdx[0]??0, e, 'DDI overflow â†’ holding');
    }
  }

  /* ====== Fly-Raft strict ====== */
  let flyIdx = [...Array(N).keys()].filter(i=>B[i].tagFly);
  const frRows = filtered.filter(r=>r.isFR && !r.isDDI);
  if(frRows.length && !flyIdx.length && N){ B[N-1].tagFly=true; flyIdx=[N-1]; pushMsg('Auto-tagged latest boat as Fly-Raft.','warn'); }
  for(const r of frRows){
    const e = entryFromRows([r], true, ['F+R']);
    let placed=false;
    for(const i of flyIdx.slice().sort((a,b)=>b-a)){ // prefer latest
      if(B[i].count + e.count <= eff(B[i])){ placed=safeAddEntry(i,e); if(placed) break; }
      const seen=new Set();
      if(rippleFree(i, e.count, r, 3, seen)){ placed=safeAddEntry(i,e); if(placed){ e.highlights.add('Ripple move'); break; } }
      if(!placed){
        const deficit = e.count - (eff(B[i]) - B[i].count);
        if(deficit>0 && freeWithHolding(i, deficit)){
          placed=safeAddEntry(i,e); if(placed){ e.highlights.add('Placed via holding'); break; }
        }
      }
    }
    if(!placed){
      pushMsg('F+R overflow: moved pax into holding; will attempt later.','warn');
      moveToHold(flyIdx[flyIdx.length-1] ?? (N-1), e, 'F+R overflow â†’ holding');
    }
  }

  /* ====== TW units (keep together) ====== */
  function baseName(clientRaw){ return norm(clientRaw.replace(/\*TW\*.*$/i,'')); }
  function parseTW(row){ const m=row.clientRaw.match(/\*TW\*\s*(.+)$/i); return m?norm(m[1]):null; }
  const byName = new Map();
  filtered.forEach(r=>{
    r.nameClean=baseName(r.clientRaw);
    r.twPartner=parseTW(r);
    byName.set(r.nameClean,(byName.get(r.nameClean)||[]).concat([r]));
  });

  const units=[]; const grouped=new Set();
  for(const r of filtered){
    // skip those already assigned through DDI/FR steps
    if(assignedTo.has(r._id) || grouped.has(r._id) || r.isDDI || r.isFR) continue;
    if(r.twPartner){
      const partner=(byName.get(norm(r.twPartner))||[]).find(x=>x!==r && !assignedTo.has(x._id) && !grouped.has(x._id) && !x.isDDI && !x.isFR);
      if(partner){
        grouped.add(r._id); grouped.add(partner._id);
        const e = entryFromRows([r,partner], false, []);
        e.highlights.add('*TW* grouped');
        units.push(e);
        continue;
      }
    }
    units.push(entryFromRows([r], false, []));
  }

  /* ====== Candidate & placement ====== */
  function candidateBoats(e){
    const f=flags(e);
    const usable=[...Array(N).keys()].filter(i=>canSeatOnBoat(e,i));
    const t = sectionTargetIndex(f.section, N);
    usable.sort((a,b)=>Math.abs(a-t)-Math.abs(b-t)||a-b);
    if(f.preferEE){
      const ee=usable.filter(i=>B[i].tagEE), rest=usable.filter(i=>!B[i].tagEE);
      return [...ee,...rest];
    }
    if(f.isOwnWayOrUnknown){
      const nonDDI = usable.filter(i=>!B[i].tagDDI);
      nonDDI.sort((a,b)=>a-b); nonDDI.reverse();
      return nonDDI.length?nonDDI:usable;
    }
    return usable;
  }

  // allowHolding toggles whether we may push more entries to HOLD to make space
  function placeUnit(e, allowHolding=true){
    const f=flags(e);
    const cands = candidateBoats(e);

    // 1) direct fits
    for(const i of cands){
      if(B[i].count + e.count <= eff(B[i])){ return safeAddEntry(i,e); }
    }
    // 2) ripple fits
    for(const i of cands){
      const seen=new Set();
      if(rippleFree(i, e.count, f.rep, 3, seen) && B[i].count + e.count <= eff(B[i])){
        const ok=safeAddEntry(i,e); if(ok){ e.highlights.add('Ripple move'); return true; }
      }
    }
    // 3) holding swap to open room (if allowed)
    if(allowHolding){
      for(const i of cands){
        const deficit = e.count - (eff(B[i]) - B[i].count);
        if(deficit>0 && freeWithHolding(i, deficit) && B[i].count + e.count <= eff(B[i])){
          const ok=safeAddEntry(i,e); if(ok){ e.highlights.add('Placed via holding'); return true; }
        }
      }
    }
    return false;
  }

  // === Order after TW: largest first (then section, then early-flag, then non-ownway) ===
  units.sort((A,B_)=>{
    if(B_.count!==A.count) return B_.count - A.count;  // biggest first
    const a=flags(A), b=flags(B_);
    const sa=secOrder(a.section), sb=secOrder(b.section);
    if(sa!==sb) return sa-sb;
    if(a.wantsEarly!==b.wantsEarly) return (b.wantsEarly?1:0)-(a.wantsEarly?1:0);
    if(a.isOwnWayOrUnknown!==b.isOwnWayOrUnknown) return (a.isOwnWayOrUnknown?1:0)-(b.isOwnWayOrUnknown?1:0);
    return 0;
  });

  for(const e of units){
    if(!placeUnit(e,true)){
      // couldn't place right now; drop to holding and weâ€™ll drain later
      HOLD.pax.push(e); HOLD.count += e.count;
      e.highlights.add('Holding (deferred)');
    }
  }

  /* ====== SOUTH: *MAP* grouping (applies after initial placement; may use holding) ====== */
  if (el('tour').value === 'south') {
    const mapRows = filtered.filter(r=>r.isMAP);
    if (mapRows.length) {
      const lastMap = mapRows.reduce((a,b)=> a._csvIndex > b._csvIndex ? a : b);
      const loc = findRowLocation(B, lastMap._id);
      if (loc) {
        const mapBoatIdx = loc.boat;
        const secondLastIdx = Math.max(0, N-2);
        const needed = mapRows.reduce((s,r)=>s+(r.num||1),0);
        const currentOnBoat = countRowsOnBoat(B[mapBoatIdx], r=>r.isMAP);
        const freeNow = eff(B[mapBoatIdx]) - B[mapBoatIdx].count + currentOnBoat;

        if (freeNow < needed && B[secondLastIdx] && B[secondLastIdx].tagFly) {
          const frEntries = B[mapBoatIdx].pax.filter(e=>flags(e).isFR);
          for (const e of frEntries) {
            if (B[secondLastIdx].count + e.count <= eff(B[secondLastIdx])) {
              safeMoveWholeEntry(mapBoatIdx, secondLastIdx, e);
              e.highlights.add('Moved to 2nd-last to make room for *MAP*');
            } else {
              const deficit = e.count - (eff(B[secondLastIdx]) - B[secondLastIdx].count);
              if(deficit>0 && freeWithHolding(secondLastIdx, deficit)){
                safeMoveWholeEntry(mapBoatIdx, secondLastIdx, e);
                e.highlights.add('Moved via holding for *MAP*');
              }
            }
          }
        }

        // Pull MAP entries into mapBoatIdx
        for (let bi=0; bi<B.length; bi++){
          for (let k=B[bi].pax.length-1; k>=0; k--){
            const e=B[bi].pax[k];
            const hasMAP = e.members.some(m=>m.isMAP);
            if(hasMAP && bi!==mapBoatIdx){
              const need=e.count;
              if (B[mapBoatIdx].count + need <= eff(B[mapBoatIdx]) || rippleFree(mapBoatIdx, need, e.members[0], 2, new Set()) || freeWithHolding(mapBoatIdx, need - (eff(B[mapBoatIdx]) - B[mapBoatIdx].count))){
                safeMoveWholeEntry(bi, mapBoatIdx, e);
                e.highlights.add('Grouped into *MAP* boat');
              }
            }
          }
        }
      } else {
        pushMsg('Could not locate the last *MAP* passenger after allocation.','warn');
      }
    }
  }

  /* ====== Sanity: unique assignment (no dup rows) ====== */
  fixDuplicateAssignments(B, assignedTo);

  /* ====== Drain holding completely (required) ====== */
  let passes=0, progressed=true;
  while (HOLD.pax.length && progressed && passes<6){
    progressed = tryDrainHoldOnce();
    passes++;
  }
  const unallocated = [];
  if (HOLD.pax.length){
    // anything left in HOLD cannot be placed within caps â†’ mark unallocated
    for(const e of HOLD.pax){ e.highlights.add('Unallocated (no room after swaps)'); unallocated.push(e); }
    HOLD.pax.length=0; HOLD.count=0;
    pushMsg('Some bookings could not be placed within capacity. See Unallocated.', 'bad');
  }
  balanceForward(B, eff, N);

  // Expose runtime
  runtime = { B, eff, N, holding: HOLD, unallocated };

  // Render
  rebuildResults(ignoredCharter);
}
// === Balance-forward pass (safe, bounded, breaks on success) ===
function balanceForward(B, eff, N){
  const secOrd = s => ({'1st':0,'2nd':1,'3rd':2,'4th':3,'Unknown':4}[s] ?? 4);
  const sectionTargetIndex = (section, n)=>{
    if(section==='1st') return 0;
    if(section==='2nd') return Math.round((n-1)/3);
    if(section==='3rd') return Math.round(2*(n-1)/3);
    if(section==='4th') return n-1;
    return n-1; // Unknown â†’ latest
  };

  function entryFlags(e){
    let isFR=false, isDDI=false, sec='Unknown';
    for(const m of e.members||[]){
      if(m && m.isFR)  isFR = true;
      if(m && m.isDDI) isDDI = true;
      if(m && m.section){
        if(sec==='Unknown' || secOrd(m.section) < secOrd(sec)) sec = m.section;
      }
    }
    return { section:sec, isFR, isDDI };
  }

  function canSeatOnBoatLocal(e, idx){
    const b = B[idx], f = entryFlags(e);
    if (f.isFR && !b.tagFly) return false;                          // Fly strictly on Fly boat
    if (f.isDDI) return !!b.tagDDI;                                  // DDI strictly on DDI boat
    if (b.tagDDI && (f.section==='3rd'||f.section==='4th'||f.section==='Unknown')) return false; // no late/unknown on DDI
    return true;
  }

  function tryFreeOnBoatByPushingLater(j, need, avoidIdx){
    let freed = 0;
    const cands = B[j].pax.slice().sort((a,b)=>{
      const sa=secOrd(entryFlags(a).section), sb=secOrd(entryFlags(b).section);
      if (sb!==sa) return sb-sa;
      return b.count - a.count;
    });

    for (const e of cands){
      for (let t=j+1; t<N; t++){
        if (t===avoidIdx) continue;
        if (!canSeatOnBoatLocal(e, t)) continue;
        if (B[t].count + e.count <= eff(B[t])){
          removeEntry(B, j, e); addEntry(B, t, e);
          e.highlights?.add?.('Pushed later');
          freed += e.count;
          break;
        }
      }
      if (freed >= need) return true;
    }
    return freed >= need;
  }

  function tryBundleSwap(i, j, e){
    const eFlags = entryFlags(e);
    const need = e.count;

    const bundleCands = B[j].pax.filter(c=>{
      const fc = entryFlags(c);
      return secOrd(fc.section) >= secOrd(eFlags.section) && canSeatOnBoatLocal(c, i);
    }).sort((a,b)=>{
      const sa=secOrd(entryFlags(a).section), sb=secOrd(entryFlags(b).section);
      if (sb!==sa) return sb-sa;
      return b.count - a.count;
    });

    let tot=0, bundle=[];
    for(const c of bundleCands){
      if (B[i].count - e.count + tot + c.count <= eff(B[i])){ // i must stay in cap after swap
        bundle.push(c); tot += c.count;
        if (tot >= need) break;
      }
    }
    if (tot < need) return false;
    if (B[j].count - tot + e.count > eff(B[j])) return false; // j must also stay in cap

    // perform swap
    for (const c of bundle){ removeEntry(B, j, c); addEntry(B, i, c); c.highlights?.add?.('Swap later'); }
    removeEntry(B, i, e); addEntry(B, j, e); e.highlights?.add?.('Swap earlier');
    return true;
  }

  // main: pull earlier-section entries forward; guard against excessive churn
  const MAX_MOVES_PER_ENTRY = 3;

  for (let i = N-1; i > 0; i--){
    // iterate with index since we mutate B[i].pax
    for (let k = 0; k < B[i].pax.length; k++){
      const e = B[i].pax[k];
      // stash per-entry move counter
      if (e.__bf_moves == null) e.__bf_moves = 0;
      if (e.__bf_moves >= MAX_MOVES_PER_ENTRY) continue;

      const f = entryFlags(e);
      const target = sectionTargetIndex(f.section, N);
      if (i <= target) continue; // already early enough

      let movedOut = false;

      // try each earlier boat from i-1 down to target
      for (let j = i-1; j >= target; j--){
        if (!canSeatOnBoatLocal(e, j)) continue;

        // 1) direct fit
        if (B[j].count + e.count <= eff(B[j])){
          removeEntry(B, i, e); addEntry(B, j, e);
          e.highlights?.add?.('Balanced earlier');
          e.__bf_moves++; movedOut = true;
          k--; // adjust iteration because we removed current e from B[i]
          break; // IMPORTANT: stop scanning j after success
        }

        // 2) free capacity on j by pushing later entries right
        const need = e.count - (eff(B[j]) - B[j].count);
        if (need > 0){
          if (tryFreeOnBoatByPushingLater(j, need, i) && B[j].count + e.count <= eff(B[j])){
            removeEntry(B, i, e); addEntry(B, j, e);
            e.highlights?.add?.('Balanced earlier (freed)');
            e.__bf_moves++; movedOut = true;
            k--;
            break; // IMPORTANT
          }
        }

        // 3) bundle swap between j (earlier) and i (later)
        if (tryBundleSwap(i, j, e)){
          e.__bf_moves++; movedOut = true;
          k--; // e left B[i]
          break; // IMPORTANT
        }
      }

      // if we successfully moved e out of boat i, stop processing that e in this i-loop
      if (movedOut) continue;
    }
  }

  // cleanup private counters
  for (const b of B){ for (const e of b.pax){ delete e.__bf_moves; } }
}


/* ========= Dup checker/fixer ========= */
function fixDuplicateAssignments(B, assignedTo){
  const seen = new Map(); // rowId -> first {boat,entry}
  for (let i=0;i<B.length;i++){
    for (let j=0;j<B[i].pax.length;j++){
      const e=B[i].pax[j];
      for (let mIdx=e.members.length-1; mIdx>=0; mIdx--){
        const r=e.members[mIdx];
        if(seen.has(r._id)){
          e.members.splice(mIdx,1);
          e.count -= (r.num||1);
          B[i].count -= (r.num||1);
          pushMsg(`Removed duplicate: ${r.clientRaw} (kept earliest placement)`, 'warn');
        }else{
          seen.set(r._id, {boat:i,entry:j});
          assignedTo.set(r._id, i);
        }
      }
      if(e.members.length===0){
        B[i].pax.splice(j,1); j--;
      }
    }
  }
}

/* ========= Finders & counters ========= */
function findRowLocation(B, rowId){
  for (let i=0;i<B.length;i++){
    for (let j=0;j<B[i].pax.length;j++){
      const e=B[i].pax[j];
      for (const r of e.members){
        if(r._id===rowId) return {boat:i, entry:j};
      }
    }
  }
  return null;
}
function countRowsOnBoat(boat, pred){
  let s=0; for (const e of boat.pax){ for (const r of e.members){ if(pred(r)) s+= (r.num||1); } } return s;
}

/* ========= Drag & drop (delegated) ========= */
function enableDragAndDrop(){
  const host = el('results');
  if(!runtime || !host) return;

  // Clean previous listeners by cloning
  const clone = host.cloneNode(true);
  host.parentNode.replaceChild(clone, host);
  const root = clone;

  let dragRowId = null;
  root.addEventListener('dragstart', ev=>{
    const tr = ev.target.closest('tr[data-rowid]');
    if(!tr) return;
    dragRowId = tr.dataset.rowid;
    try{ ev.dataTransfer.setData('text/plain', dragRowId); }catch{}
    ev.dataTransfer.effectAllowed = 'move';
  });
  root.addEventListener('dragover', ev=>{
    const tb = ev.target.closest('tbody[data-boatidx]');
    if(!tb) return;
    ev.preventDefault();
    tb.classList.add('droptarget');
    ev.dataTransfer.dropEffect = 'move';
  });
  root.addEventListener('dragleave', ev=>{
    const tb = ev.target.closest('tbody[data-boatidx]');
    if(tb) tb.classList.remove('droptarget');
  });
  root.addEventListener('drop', ev=>{
    const tb = ev.target.closest('tbody[data-boatidx]');
    if(!tb) return;
    ev.preventDefault();
    tb.classList.remove('droptarget');
    const rowId = dragRowId || (ev.dataTransfer && ev.dataTransfer.getData('text/plain'));
    if(!rowId) return;
    manualMoveRow(rowId, +tb.dataset.boatidx);
    dragRowId = null;
  });
}

function manualMoveRow(rowId, targetBoat){
  const {B, eff} = runtime;
  const loc = findRowLocation(B, rowId);
  if(!loc){ pushMsg('Could not locate row to move.','bad'); return; }
  const e = B[loc.boat].pax[loc.entry];

  // Move whole entry (keeps TW together)
  const f = (function flagsLocal(){
    const any=f=>e.members.some(x=>x[f]);
    const sec=e.members.map(x=>x.section).sort((a,b)=>({'1st':0,'2nd':1,'3rd':2,'4th':3,'Unknown':4}[a]-{'1st':0,'2nd':1,'3rd':2,'4th':3,'Unknown':4}[b]))[0]||'Unknown';
    return { isFR:any('isFR'), isDDI:any('isDDI'), section:sec, rep:e.members[0] };
  })();

  const tgt = runtime.B[targetBoat];
  const ruleViolated = (f.isFR && !tgt.tagFly) || (f.isDDI && !tgt.tagDDI) || (tgt.tagDDI && (f.section==='3rd'||f.section==='4th'||f.section==='Unknown'));
  if(ruleViolated) e.highlights.add('Manual move â€” rule override');

  const need = e.count;
  if (runtime.B[targetBoat].count + need > eff(runtime.B[targetBoat])) {
    // try ripple; if still no space, briefly use holding swap
    if(!rippleFree(targetBoat, need, f.rep, 1, new Set())){
      const deficit = need - (eff(runtime.B[targetBoat]) - runtime.B[targetBoat].count);
      freeWithHolding(targetBoat, deficit);
    }
  }

  removeEntry(runtime.B, loc.boat, e);
  addEntry(runtime.B, targetBoat, e);

  rebuildResults();
}

/* ========= Results render + CSV ========== */
function rebuildResults(ignoredCharter=[]){
  const results = el('results'); results.innerHTML='';
  if(!runtime){ results.textContent='Nothing to show yet.'; return; }
  const {B, eff} = runtime;

  if(ignoredCharter.length) pushMsg(`Ignored ${ignoredCharter.length} charter booking(s).`,'warn');

  let total=0, totalCap=0; B.forEach(b=>{ total+=b.count; totalCap+=eff(b); });

  const out=[["Boat","DepartureOrder","Boat Hold Seats","Boat Tags","Client","No. Pass.","P/U Point","Time","Pickup Notes","Phone","Tags","Highlights","Pickup Section"]];

  B.forEach((b,idx)=>{
    const head=document.createElement('div');
    head.style.display='flex'; head.style.justifyContent='space-between'; head.style.alignItems='center';
    head.style.margin='8px 0 4px';
    const tagStr=[b.tagDDI?'DDI':'', b.tagFly?'Fly-Raft':'', b.tagEE?'EE':''].filter(Boolean).join('; ');
    head.innerHTML = `<div><b>${idx+1}. ${b.name}</b> &nbsp; <span class="pill ${b.count<=eff(b)?'ok':'bad'}">${b.count}/${eff(b)}</span></div>
      <div class="chips">
        ${b.tagDDI?'<span class="chip">DDI</span>':''}
        ${b.tagFly?'<span class="chip">Fly-Raft</span>':''}
        ${b.tagEE?'<span class="chip">EE</span>':''}
        ${b.toilet?'<span class="chip">ðŸš»</span>':''}
      </div>`;
    results.appendChild(head);

    const table=document.createElement('table');
    table.innerHTML = `<thead><tr>
      <th>#</th><th>Client</th><th>No. Pass.</th><th>P/U Point</th><th>Time</th><th>Section</th><th>Tags</th><th>Highlights</th>
    </tr></thead>`;
    const tb=document.createElement('tbody');
    tb.dataset.boatidx = String(idx);

    if(b.hold>0){
      const tr=document.createElement('tr');
      tr.innerHTML=`
        <td>â€”</td><td>SEAT HOLD</td><td>${b.hold}</td>
        <td></td><td></td><td></td>
        <td><span class="pill tag">Hold</span></td>
        <td><span class="pill warn">Seats reserved; not for allocation</span></td>`;
      tb.appendChild(tr);
      out.push([b.name,idx+1,b.hold,tagStr,'SEAT HOLD',b.hold,'','','','','Hold','Seats reserved; not for allocation','']);
    }

    let rowNumber=0;
    for(const e of b.pax){
      const tagHTML = [...e.tags].map(t=>`<span class="pill tag">${t}</span>`).join(' ');
      const hlHTML  = [...e.highlights].map(t=>`<span class="pill warn">${escapeHtml(t)}</span>`).join(' ');
      for(const r of e.members){
        const tr=document.createElement('tr');
        tr.dataset.rowid = r._id;
        tr.innerHTML = `
          <td>${++rowNumber}</td>
          <td>${escapeHtml(r.clientRaw)}</td>
          <td>${r.num||1}</td>
          <td>${escapeHtml(r.pu)}</td>
          <td>${r.time||''}</td>
          <td>${r.section}</td>
          <td>${tagHTML}</td>
          <td>${hlHTML}</td>`;
        tb.appendChild(tr);
        out.push([b.name,idx+1,b.hold,tagStr,r.clientRaw,(r.num||1),r.pu,r.time||'',r.notes||'',r.phone||'', [...e.tags].join('; '), [...e.highlights].join('; '), r.section]);
      }
    }
    table.appendChild(tb);
    results.appendChild(table);
  });

  const summary=document.createElement('div'); summary.className='status';
  summary.style.margin='10px 0 0';
  summary.innerHTML = `Total allocated: <b>${total}</b> / Effective capacity: <b>${totalCap}</b>
    ${total>totalCap?'<span class="pill bad" style="margin-left:6px">Over capacity</span>':''}
    <span class="mono" style="margin-left:8px;opacity:.6">v=${APP_VERSION} Â· breathing-room guard</span>`;
  results.prepend(summary);

  // Enable drag & drop via delegation (robust across browsers)
  enableDragAndDrop();

  // Hook CSV download to current runtime state
  const dl=document.getElementById('download');
  dl.onclick=()=>downloadCSV(out);
  dl.disabled=false;

  setStatus('Allocation complete. Drag rows between boats if needed.');
}

function downloadCSV(outRows){
  const toCSV = rows => rows.map(r=>r.map(v=>{
    if(v==null) return '';
    const s=String(v);
    return /[",\n]/.test(s) ? '"' + s.replace(/"/g,'""') + '"' : s;
  }).join(',')).join('\n');
  const csv = toCSV(outRows);
  const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob);
  const a=document.createElement('a'); a.href=url; a.download=`boat-split-${document.getElementById('tour').value}-${new Date().toISOString().slice(0,10)}.csv`; document.body.appendChild(a); a.click(); a.remove();
}

/* ========= Wiring ========= */
function wire(){
  el('resetBoats').onclick=()=>{ boats=cloneBoats(); renderBoats(); setStatus('Boats reset.'); };
  el('run').onclick=allocate;

  el('file').addEventListener('change', async e=>{
    clearMsgs(); popups=[];
    const f=e.target.files?.[0]; if(!f) return;
    const text = await f.text();
    const raw = parseCSV(text);

    // IGNORE BLANK ROWS (header may not be first line)
    const headerRowIndex = raw.findIndex(r => !rowIsBlank(r));
    if(headerRowIndex === -1){ setStatus('Empty CSV.'); return; }
    const header = raw[headerRowIndex].map(h=>h.trim());
    const data = raw.slice(headerRowIndex+1).filter(r => !rowIsBlank(r));

    const idxClient=findColIndex(header,COL_ALIASES.client);
    const idxNum   =findColIndex(header,COL_ALIASES.num);
    const idxPU    =findColIndex(header,COL_ALIASES.pu);
    const idxTime  =findColIndex(header,COL_ALIASES.time);
    const idxNotes =findColIndex(header,COL_ALIASES.notes);
    const idxPhone =findColIndex(header,COL_ALIASES.phone);

    if(idxClient<0 || idxPU<0){ setStatus('Missing required columns: need at least Client and P/U Point.'); return; }

    // Parse rows
    const parsed = data.map((r,i)=>{
      const clientRaw = norm(r[idxClient]);
      const numRaw = (idxNum>=0 ? r[idxNum] : '').toString();
      const FRfromCount  = /\(\s*F\s*\+\s*R\s*\)/i.test(numRaw);
      const FRfromClient = /\(\s*F\s*\+\s*R\s*\)/i.test(clientRaw);
      const FRfromNotes  = /\(\s*F\s*\+\s*R\s*\)/i.test(norm(idxNotes>=0?r[idxNotes]:'')); 
      const flyFromAny   = FRfromCount || FRfromClient || FRfromNotes;

      const numMatch = numRaw.match(/\d+/);
      const num = Math.max(1, numMatch ? parseInt(numMatch[0],10) : 1);

      const pu   = norm(r[idxPU]);
      const time = norm(idxTime>=0?r[idxTime]:'');
      const notes= norm(idxNotes>=0?r[idxNotes]:'');
      const phone= norm(idxPhone>=0?r[idxPhone]:'');
      const timeMins = parseTimeToSortable(time);

      return { clientRaw, num, pu, time, timeMins, notes, phone, flyFromCount: flyFromAny, _csvIndex:i };
    });

    // STRONG de-dup: key on normalized client + pu + HH:MM (or empty) + phone (if present)
    const normTime = s=> {
      const m = norm(s); if(!m) return '';
      const mins = parseTimeToSortable(m); if(mins==null) return '';
      const hh = Math.floor(mins/60).toString().padStart(2,'0');
      const mm = (mins%60).toString().padStart(2,'0');
      return `${hh}:${mm}`;
    };
    const keyFor = o => `${lower(o.clientRaw)}|${lower(o.pu)}|${normTime(o.time)}|${lower(o.phone)}`;
    const acc = new Map();
    for(const r of parsed){
      const k = keyFor(r);
      if(acc.has(k)){ acc.get(k).num += r.num; }
      else { acc.set(k, {...r}); }
    }
    const merged = Array.from(acc.values());
    const mergedDelta = parsed.length - merged.length;
    if(mergedDelta>0) pushMsg(`Coalesced ${mergedDelta} duplicate row(s).`,'ok');

    rows = merged.map(r => ({...r, _id: Math.random().toString(36).slice(2)}));

    el('results').innerHTML='<span class="muted">File loaded. Configure boats, then <b>Allocate</b>.</span>';
    el('download').disabled=true;
    setStatus(`Loaded ${rows.length} unique bookings. (v=${APP_VERSION})`);
  });
}

/* ========= Boot ========= */
function init(){
  try{
    boats = cloneBoats();
    renderBoats();
    wire();
    setStatus(`Ready. (v=${APP_VERSION} Â· breathing-room guard)`);
  }catch(e){
    const host = document.querySelector('#results');
    const pre = document.createElement('div');
    pre.className='err';
    pre.textContent='Init error: '+(e&&e.stack?e.stack:String(e));
    host?.prepend(pre);
  }
}
if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }

/* helper needed by wire() â€” keep here for scope */
function findColIndex(h,keys){
  const lowerh=h.map(x=>x.toLowerCase());
  for(const k of keys){ const i=lowerh.indexOf(k); if(i!==-1) return i; }
  for(let i=0;i<lowerh.length;i++){ if(keys.some(k=>lowerh[i].includes(k))) return i; }
  return -1;
}
</script>
</body>
</html>
